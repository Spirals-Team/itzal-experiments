/**
 * SQL Grammar (JavaCC)
 *
 * Mckoi SQL Database ( http://www.mckoi.com/database )
 * Copyright (C) 2000, 2001  Diehl and Associates, Inc.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * Version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License Version 2 for more details.
 *
 * You should have received a copy of the GNU General Public License
 * Version 2 along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Change Log:
 * 
 * 
 */

options {
  STATIC = false;
//  IGNORE_CASE = true;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(SQL)

package com.mckoi.database.sql;

import com.mckoi.database.Assignment;
import com.mckoi.database.JoiningSet;
import com.mckoi.database.Expression;
import com.mckoi.database.Variable;
import com.mckoi.database.FunctionDef;
import com.mckoi.database.FunctionFactory;
import com.mckoi.database.Operator;
import com.mckoi.database.StatementTree;
import com.mckoi.database.ParameterSubstitution;
import com.mckoi.database.global.*;
import com.mckoi.database.interpret.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Stack;

public class SQL {

  // State variables for the parser,

  /**
   * Set to true if the SQL identifiers are converted to upper case.
   * NOTE: Purely experimental feature!
   */
  private boolean case_insensitive_identifiers = false;
  
  /**
   * The parameter id.
   */
  private int parameter_id = 0;
  
  
  /**
   * Resets the parameter id.  This MUST be called before a parser is used
   * to parse a statement.
   */
  public void reset() {
    parameter_id = 0;
  }
  
  /**
   * Creates and returns a parameter substitution.  This is called when the
   * parser comes across a '?' style object.  This object is used to mark an
   * expression with a place mark that can be substituted for a value later.
   */
  public ParameterSubstitution createSubstitution(String image) {
    ParameterSubstitution ps = new ParameterSubstitution(parameter_id);
    ++parameter_id;
    return ps;
  }
  
  
//  /**
//   * The parameters that we have passed into the SQL statement.
//   */
//  Object[] params = new Object[0];
//  int parameter_index = -1;

//  /**
//   * Sets the parameters for this SQL parser.
//   */
//  public void setParameters(Object[] params) {
//    this.params = params;
//    for (int i = 0; i < params.length; ++i) {
//      if (params[i] == null) {
//        params[i] = NullObject.NULL_OBJ;
//      }
//    }
//    parameter_index = -1;
//  }

//  /**
//   * Returns the next parameter.  This is called when a '?' type parameter
//   * reference is seen.
//   */
//  public Object nextParameter() {
//    ++parameter_index;
//    return params[parameter_index];
//  }
  
//  /**
//   * Converts the parameter string (eg. "%3", or "?") to the parameter
//   * argument that was passed into the statement (eg. params[3] or the
//   * next parameter in the case of "?").
//   */
//  public Object getParameter(String param_ref) {
//    if (param_ref.equals("?")) {
//      return nextParameter();
//    }
//    else if (param_ref.startsWith("%")) {
//      int i = Integer.parseInt(param_ref.substring(1));
//      if (i >= 0 && i < params.length) {
//        return params[i];
//      }
//      else {
//        throw new Error("Param reference out of range.");
//      }
//    }
//    throw new Error("Error, parameter string incorrect.");
//  }

//  /**
//   * Used to toggle whether this parser uses case insensitive
//   * identifiers or not.  If this is set to true, call identifiers
//   * are made lower case.  This is false by default.
//   */
//  public void setCaseInsensitiveIdentifiers(boolean case_insensitive) {
//    case_insensitive_identifiers = case_insensitive;
//  }

  /**
   * If the parser has been defined as case insensitive then this
   * returns the uppercase version of the given string.
   */
  public String caseCheck(String identif) {
//    if (case_insensitive_identifiers) {
//      return identif.toUpperCase();
//    }
    return identif;
  }
  
  /**
   * Helper for expression parsing.
   * Called when an end parenthese has been found.
   */
  public void expEndParen(Expression exp, Stack stack) {
    Operator op = (Operator) stack.pop();
    while (!op.is("(")) {
      addOperatorToExpression(exp, op);
      op = (Operator) stack.pop();
    }
  }
  
  /**
   * Helper for expression parsing.
   * Called when an operator has been read in.  This needs to check precedence
   * and add the operator to the expression as appropriate.
   */
  public void expOperator(Expression exp, Stack stack, Operator op) {
    int precedence = op.precedence();
    flushOperatorStack(exp, stack, precedence);
    stack.push(op);
  }

  /**
   * Flush the operator stack until the stack is either empty or the top
   * element is either a "(" or of a precedence lower than the given
   * precedence.
   */
  public void flushOperatorStack(Expression exp, Stack stack, int precedence) {
    if (!stack.empty()) {
      Operator top_op = (Operator) stack.pop();
      while (!top_op.is("(") && top_op.precedence() > precedence) {
        addOperatorToExpression(exp, top_op);
        if (stack.empty()) {
          return;
        }
        top_op = (Operator) stack.pop();
      }
      stack.push(top_op);
    }
  }
  
  /**
   * Helper for expression parsing.
   * Called when an entire expression has been read in.  We need to empty
   * the stack.
   */
  public void expEnd(Expression exp, Stack stack) {
    while (!stack.empty()) {
      Operator op = (Operator) stack.pop();
      addOperatorToExpression(exp, op);
    }
  }

  /**
   * Helper for expression parsing.
   * Adds an operator to the given expression.
   */
  public void addOperatorToExpression(Expression exp, Operator op) {
    if (op.is("not")) {
      exp.addElement(null);
    }
    exp.addOperator(op);
  }

  
  
//  public static void printExpressionList(Expression[] exp_arr) {
//    System.out.println(exp_arr);
//    for (int p = 0; p < exp_arr.length; ++p) {
//      System.out.println(exp_arr[p]);
//    }
//  }
  

  public static void main(String args[]) throws ParseException {
    SQL parser = new SQL(System.in);
    parser.Test();
  }

}

PARSER_END(SQL)


SKIP : {

  " "
| "\t"
| "\n"
| "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"--" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
//|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">

}

TOKEN: {

  <STAR:       "*" >

| <ASSIGNMENT: "=" >
| <EQUALS:     "==" >
| <GR:         ">" >
| <LE:         "<" >
| <GREQ:       ">=" >
| <LEEQ:       "<=" >
| <NOTEQ:      "!=" | "<>" >
| <DIVIDE:     "/" >
| <ADD:        "+" >
| <SUBTRACT:   "-" >

}

TOKEN [IGNORE_CASE] : {
  
    <BOOLEAN_LITERAL: "true" | "false" >
  | <NULL_LITERAL:    "null" >
      // NOTE: Handling regex literals is a horrible horrible hack.  The <REGEX_LITERAL> 
      //   token starts with 'regex /' and the regex string follows.
      //   The reason for this hack is because / clashes with <DIVIDE>
  | <REGEX_LITERAL:   "regex /" (~["/","\n","\r"] | "\\/" )* "/" ( "i" | "s" | "m" )* >
  
}

TOKEN [IGNORE_CASE] : { /* KEYWORDS */

  <DROP:        "drop">
| <SHOW:        "show">
| <ALTER:       "alter">
| <SELECT:      "select">
| <UPDATE:      "update">
| <CREATE:      "create">
| <DELETE:      "delete">
| <INSERT:      "insert">
| <COMMIT:      "commit">
| <COMPACT:     "compact">
| <EXPLAIN:     "explain">
| <ROLLBACK:    "rollback">
| <OPTIMIZE:    "optimize">
| <DESCRIBE:    "describe">
| <SHUTDOWN:    "shutdown">

| <IS:          "is">
| <AS:          "as">
| <ON:          "on">
| <IF:          "if">
| <ALL:         "all">
| <ANY:         "any">
| <SET:         "set">
| <USE:         "use">
| <ASC:         "asc">
| <NEW:         "new">
| <SQLADD:      "add">
| <BOTH:        "both">
| <SOME:        "some">
| <FROM:        "from">
| <LEFT:        "left">
| <DESC:        "desc">
| <INTO:        "into">
| <JOIN:        "join">
| <TRIM:        "trim">
| <VIEW:        "view">
| <COUNT:       "count">
| <WHERE:       "where">
| <RIGHT:       "right">
| <TABLE:       "table">
| <LIMIT:       "limit">
| <INNER:       "inner">
| <INDEX:       "index">
| <CROSS:       "cross">
| <OUTER:       "outer">
| <CHECK:       "check">
| <USING:       "using">
| <UNION:       "union">
| <EXCEPT:      "except">
| <IGNORE:      "ignore">
| <SCHEMA:      "schema">
| <EXISTS:      "exists">
| <VALUES:      "values">
| <HAVING:      "having">
| <UNIQUE:      "unique">
| <SQLCOLUMN:   "column">
| <LEADING:     "leading">
| <NATURAL:     "natural">
| <BETWEEN:     "between">
| <TRIGGER:     "trigger">
| <SQLDEFAULT:  "default">
| <TRAILING:    "trailing">
//| <NOTNULL:     "not null">
| <GROUPBY:     "group by">
| <ORDERBY:     "order by">
| <DEFERRED:    "deferred">
| <DISTINCT:    "distinct">
| <IMMEDIATE:   "immediate">
| <INITIALLY:   "initially">
| <TEMPORARY:   "temporary">
| <INTERSECT:   "intersect">
| <CONSTRAINT:  "constraint">
| <DEFERRABLE:  "deferrable">
| <REFERENCES:  "references">

| <PRIMARY:     "primary">
| <FOREIGN:     "foreign">
| <KEY:         "key">

| <INDEX_NONE:  "index_none">
| <INDEX_BLIST: "index_blist">

| <GROUPMAX:    "group max">

// Data types,

| <BIT:         "bit">
| <INT:         "int">
| <REAL:        "real">
| <BLOB:        "blob">
| <CHAR:        "char">
| <TEXT:        "text">
| <DATE:        "date">
| <TIME:        "time">
| <FLOAT:       "float">
| <BIGINT:      "bigint">
| <DOUBLE:      "double">
| <STRING:      "string">
| <BINARY:      "binary">
| <NUMERIC:     "numeric">
| <DECIMAL:     "decimal">
| <BOOLEAN:     "boolean">
| <TINYINT:     "tinyint">
| <INTEGER:     "integer">
| <VARCHAR:     "varchar">
| <SMALLINT:    "smallint">
| <VARBINARY:   "varbinary">
| <TIMESTAMP:   "timestamp">
| <JAVA_OBJECT: "java_object">
| <LONGVARCHAR: "longvarchar">
| <LONGVARBINARY: "longvarbinary">

| <TRANSACTIONISOLATIONLEVEL: "transaction isolation level">
| <AUTOCOMMIT:                "auto commit">
| <READCOMMITTED:             "read committed">
| <READUNCOMMITTED:           "read uncommitted">
| <REPEATABLEREAD:            "repeatable read">
| <SERIALIZABLE:              "serializable">

| <NO_ACTION:                 "no action">
| <CASCADE:                   "cascade">
| <SET_NULL:                  "set null">
| <SET_DEFAULT:               "set default">



//| <DATA_TYPE: "boolean" | "bit" | "tinyint" | "smallint" | "integer" | "bigint" | "float" | "real" |
//              "double" | "numeric" | "decimal" | "char" | "varchar" | "longvarchar" | "string" |
//              "date" | "time" | "timestamp" | "binary" | "varbinary" | "longvarbinary" >

// NOTE: OPERATOR doesn't match '*' or '=' because we use * and = to mean different things
//  <OPERATOR: ( "==" | ">" | "<" | ">=" | "<=" | "!=" | "<>" | "/" | "+" | "-" |
//               "like" | "not like" | "regex" | "and" | "or" ) >

| <LIKE:       "like" >
//| <NOTLIKE:    "not like" >
| <REGEX:      "regex" >
| <AND:        "and" >
| <OR:         "or" >
| <IN:         "in" >
//| <NOTIN:      "not in" >

| <NOT:        "not">

}

TOKEN : {

    <NUMBER_LITERAL:
       (["-","+"])? ( ( (["0"-"9"])+ ( "." (["0"-"9"])+ )? )
                 |( "." (["0"-"9"])+ ) )
                            ( "E" (["-","+"])? (["0"-"9"])+ )? 
    
//        ("-")? (["0"-"9"])+ "." (["0"-"9"])*
//      | ("-")? "." (["0"-"9"])+
//      | ("-")? (["0"-"9"])+
//      | 
    >
  | <STRING_LITERAL:   "'" ( "''" | "\\" ["a"-"z", "\\", "%", "_", "'"] | ~["'","\\"] )* "'" >
//  | <STRING_LITERAL:   "'" ( "''" | ~["'","\n","\r","\\"] )* "'" >
  | <QUOTED_VARIABLE: "\"" ( ["a"-"z", "A"-"Z", "_", "0"-"9", "."] )* "\"" >
  
}

TOKEN : {  /* IDENTIFIERS */

  <IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> )* >
| <DOT_DELIMINATED_REF: <IDENTIFIER> ( "." <IDENTIFIER> )* >
| <QUOTED_DELIMINATED_REF: <QUOTED_VARIABLE> ( "." <QUOTED_VARIABLE> )* >
| <JAVA_OBJECT_ARRAY_REF: <DOT_DELIMINATED_REF> "[]" >
| <CTALIAS: <IDENTIFIER> >
| <GLOBVARIABLE: <DOT_DELIMINATED_REF> ".*" >
| <QUOTEDGLOBVARIABLE: <QUOTED_DELIMINATED_REF> ".*" >
| <PARAMETER_REF: "?" >

| <#LETTER: ["a"-"z", "A"-"Z", "_"] >
| <#DIGIT: ["0"-"9"]>

}


void Test() :
{  }
{
  ( parseExpression() ";" )
  
  { }
}


// Parses a single expression.  Useed in 'com.mckoi.database.Expression.parse' method.
Expression parseExpression() :
{ Expression exp;
}
{
  exp = DoExpression() <EOF>
  
  { return exp; }
}

// Statement that ends with a ';'
StatementTree Statement() :
{ StatementTree ob; }
{
  (
    (   ob=Select()
      | ob=Update()
      | ob=Alter()
      | ob=Compact()
      | ob=Create()
      | ob=Drop()
      | ob=Delete()
      | ob=Insert()
      | ob=Describe()
      | ob=Show()

      
      | ob=CompleteTransaction()    // Either 'commit' or 'rollback'
      | ob=Set()
      
      | ob=ShutDown()
    )
    ( ";" | <EOF> )
  )

  { return ob; }
}
  
// All statements that start with <CREATE>
StatementTree Create() :
{ StatementTree ob;
}
{
  (  <CREATE> 
    (   ob=CreateTable()
      | ob=CreateTrigger()
      | ob=CreateIndex()
      | ob=CreateSchema()
//      | ob=CreateView()
    )
  )
  
  { return ob; }
}  


// All statements that start with <DROP>
StatementTree Drop() :
{ StatementTree ob;
}
{
  (  <DROP>
    (   ob=DropTable()
      | ob=DropTrigger()
      | ob=DropIndex()
      | ob=DropSchema()
//      | ob=DropView()
    )
  )
  
  { return ob; }
}




StatementTree Select() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Select");
  TableSelectExpression table_expr;
  ArrayList order_by = new ArrayList();
}
{
  ( table_expr = GetTableSelectExpression()
    [ <ORDERBY> SelectOrderByList(order_by) ]
  )

  { cmd.putObject("table_expression", table_expr);
    cmd.putObject("order_by", order_by);
    return cmd; }
}


StatementTree Update() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.UpdateTable");
  String table_name;
  ArrayList assignments = new ArrayList();
  SearchExpression where_clause = new SearchExpression();
  int limit = -1;
}
{
  ( <UPDATE> table_name = TableName() <SET> AssignmentList(assignments)
        [ <WHERE> ConditionsExpression(where_clause) ]
        [ <LIMIT> limit = PositiveIntegerConstant() ] 
  )

  { cmd.putObject("table_name", table_name);
    cmd.putObject("assignments", assignments);
    cmd.putObject("where_clause", where_clause);
    cmd.putInt("limit", limit);
    return cmd; }
}


StatementTree Alter() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.AlterTable");
  String table_name;
  AlterTableAction action;
  StatementTree create_statement;
}
{
  (   LOOKAHEAD(2) <ALTER> <TABLE> table_name=TableName() action=GetAlterTableAction()
      { cmd.putObject("table_name", table_name);
        cmd.putObject("alter_action", action);
      }
    | <ALTER> <CREATE> create_statement = CreateTable()
      { cmd.putObject("create_statement", create_statement); }
  )

  { return cmd; }
}


StatementTree Compact() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Compact");
  String table_name;
}
{
  (    <COMPACT> <TABLE> table_name=TableName()
  )
  
  { cmd.putObject("table_name", table_name);
    return cmd; }
}


StatementTree CreateTable() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CreateTable");
  boolean temporary = false;
  boolean only_if_not_exists = false;
  String table_name;
  ArrayList column_list = new ArrayList();
  ArrayList constraint_list = new ArrayList();
  Expression check_expression;
}
{
  (  [ <TEMPORARY> { temporary = true; } ]
       <TABLE>
     [ <IF> <NOT> <EXISTS> { only_if_not_exists = true; } ]
       table_name = TableName()
       ColumnDeclarationList(column_list, constraint_list)
     [ <CHECK> check_expression = DoExpression()
            { ConstraintDef check_constraint = new ConstraintDef();
              check_constraint.setCheck(check_expression);
              constraint_list.add(check_constraint); }
     ]

//     [ CreateOptions(statement) ]
//     [ <AS> statement.select = Select() ]
  )
  
  { cmd.putBoolean("temporary", temporary);
    cmd.putBoolean("only_if_not_exists", only_if_not_exists);
    cmd.putObject("table_name", table_name);
    cmd.putObject("column_list", column_list);
    cmd.putObject("constraint_list", constraint_list);
    return cmd; }
  
}


StatementTree CreateTrigger() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CreateTrigger");
  String trigger_name;
  String type;
  String table_name;
}
{
  (   <TRIGGER> trigger_name = TriggerName()
             (   <INSERT> { type = "INSERT"; }
               | <UPDATE> { type = "UPDATE"; }
               | <DELETE> { type = "DELETE"; }
             )
             <ON> table_name = TableName() 
  )
  
  { cmd.putObject("trigger_name", trigger_name);
    cmd.putObject("type", type);
    cmd.putObject("table_name", table_name);
    return cmd; }

}  


StatementTree DropTrigger() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.DropTrigger");
  String trigger_name;
}
{
  (   <TRIGGER> trigger_name = TriggerName() )
  
  { cmd.putObject("trigger_name", trigger_name);
    return cmd; }
}  


StatementTree CreateSchema() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Schema");
  cmd.putObject("type", "create");
  String schema_name;
}
{
  (   <SCHEMA> schema_name = SchemaName() )
  
  { cmd.putObject("schema_name", schema_name);
    return cmd; }
}


StatementTree DropSchema() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Schema");
  cmd.putObject("type", "drop");
  String schema_name;
}
{
  (   <SCHEMA> schema_name = SchemaName() )
  
  { cmd.putObject("schema_name", schema_name);
    return cmd; }
}


StatementTree CreateView() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CreateView");
  String view_name;
  TableSelectExpression select_statement;
}
{
  (   <VIEW> view_name = TableName() select_statement = GetTableSelectExpression() )

  { cmd.putObject("view_name", view_name);
    cmd.putObject("select_statement", select_statement);
    return cmd; }
}


StatementTree CreateIndex() :
{
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.NoOp");
}
{
  (   [<UNIQUE>] <INDEX> IndexName() <ON>
        TableName() "(" BasicColumnList(new ArrayList()) ")" )
  
  { return cmd; }
}


StatementTree DropTable() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.DropTable");
  boolean only_if_exists = false;
  String table_name;
  ArrayList table_list = new ArrayList();
}
{
  (   <TABLE>
         [ <IF> <EXISTS> { only_if_exists = true; } ]
         table_name = TableName() { table_list.add(table_name); }
           ( "," table_name = TableName() { table_list.add(table_name); } )*
  )
  
  { cmd.putBoolean("only_if_exists", only_if_exists);
    cmd.putObject("table_list", table_list);
    return cmd; }
  
}


StatementTree DropIndex() :
{
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.NoOp");
}
{
  (   <INDEX> IndexName() <ON> TableName()
  )
  
  { return cmd; }

}


StatementTree Delete() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Delete");
  String table_name;
  SearchExpression where_clause = new SearchExpression();
  int limit = -1;
}
{

  ( <DELETE> <FROM> table_name = TableName()
        [ <WHERE> ConditionsExpression(where_clause) ]
        [ <LIMIT> limit = PositiveIntegerConstant() ] 
  )

  { cmd.putObject("table_name", table_name);
    cmd.putObject("where_clause", where_clause);
    cmd.putInt("limit", limit);
    return cmd; }

}


StatementTree Insert() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Insert");
  String table_name;
  ArrayList col_list = new ArrayList();
  ArrayList data_list = new ArrayList(); // ( Array of Expression[] )
  StatementTree select = null;
  ArrayList assignments = new ArrayList();
  String type;
}
{

  ( <INSERT> [ <INTO> ] table_name = TableName()
    (   [ "(" BasicColumnList(col_list) ")" ]
           (   <VALUES> InsertDataList(data_list)  { type = "from_values"; }
             | select = Select()                   { type = "from_select"; }
           )
      | <SET> AssignmentList(assignments)          { type = "from_set"; }
    )
  )

  { cmd.putObject("table_name", table_name);
    cmd.putObject("col_list", col_list);
    cmd.putObject("data_list", data_list);
    cmd.putObject("select", select);
    cmd.putObject("assignments", assignments);
    cmd.putObject("type", type);
    return cmd; }

}


StatementTree Describe() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Show");
  cmd.putObject("show", "describe_table");
  String table_name;
}
{

  ( <DESCRIBE> table_name = TableName()
  )
  
  { cmd.putObject("table_name", table_name);
    cmd.putObject("where_clause", new SearchExpression());
    return cmd; }

}


StatementTree Show() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Show");
  Expression[] args = null;
  SearchExpression where_clause = new SearchExpression();
  Token t;
}
{
  ( <SHOW> 
      (   t=<IDENTIFIER>
        | t=<SCHEMA>
      )
      [ "(" args=ExpressionList() ")" ]
      [ <WHERE> ConditionsExpression(where_clause) ] )
  
  { cmd.putObject("show", t.image);
    cmd.putObject("args", args);
    cmd.putObject("where_clause", where_clause);
    return cmd; }

}


StatementTree CompleteTransaction() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CompleteTransaction");
  String command;
}
{

  (   <COMMIT>   { command = "commit"; }
    | <ROLLBACK> { command = "rollback"; }
  )

  { cmd.putObject("command", command);
    return cmd; }
}

StatementTree Set() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Set");
  Token t1;
  String value;
  Expression exp;
  String name;
}
{
  <SET>
  (   t1=<IDENTIFIER> <ASSIGNMENT> exp=DoExpression()
        { cmd.putObject("type", "VARSET");
          cmd.putObject("var_name", t1.image);
          cmd.putObject("exp", exp); }
    | <TRANSACTIONISOLATIONLEVEL> (  t1=<SERIALIZABLE> )
        { cmd.putObject("type", "ISOLATIONSET");
          cmd.putObject("var_name", "TRANSACTION ISOLATION LEVEL");
          cmd.putObject("value", t1.image); }
    | <AUTOCOMMIT> ( t1=<ON> | t1=<IDENTIFIER> )
        { cmd.putObject("type", "AUTOCOMMIT");
          cmd.putObject("value", t1.image); }
    | <SCHEMA> name=SchemaName()
        { cmd.putObject("type", "SCHEMA");
          cmd.putObject("value", name); }
  )
  
  { return cmd; }
}



StatementTree ShutDown() :
{ StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Misc");
}
{

  <SHUTDOWN>
  
  { cmd.putObject("command", "shutdown");
    return cmd; }
}





// ----------

// A table expression 
TableSelectExpression GetTableSelectExpression() :
{ TableSelectExpression table_expr = new TableSelectExpression();
  String composite = "";
  boolean is_all = false;
  TableSelectExpression next_composite_expression;
//  boolean distinct = false;
//  ArrayList columns = new ArrayList();
//  FromClause from_clause = new FromClause();
//  SearchExpression where_clause = new SearchExpression();
//  ArrayList group_by = new ArrayList();
//  Variable group_max = null;
//  SearchExpression having_clause = new SearchExpression();
}
{
  ( <SELECT>
        [ table_expr.distinct = SetQuantifier() ]
        SelectColumnList(table_expr.columns)
        [ <FROM> SelectTableList(table_expr.from_clause) ]
        [ <WHERE> ConditionsExpression(table_expr.where_clause) ]

        [ <GROUPBY> SelectGroupByList(table_expr.group_by)
          [ <GROUPMAX> table_expr.group_max = GroupMaxColumn() ] 
          [ <HAVING> ConditionsExpression(table_expr.having_clause) ] ]

        [ composite = GetComposite() [ <ALL> { is_all = true; } ]
          next_composite_expression = GetTableSelectExpression()
          { table_expr.chainComposite(next_composite_expression, composite, is_all); } 
        ]
  )
  { return table_expr; }
}

AlterTableAction GetAlterTableAction() :
{ String col_name, con_name;
  ColumnDef column_def;
  ConstraintDef constraint_def;
  Expression default_exp;
  AlterTableAction action = new AlterTableAction();
}
{
  (   <SQLADD>
      (   [ LOOKAHEAD(2) <SQLCOLUMN> ] column_def=ColumnDefinition()
          { action.setAction("ADD");
            action.addElement(column_def);
          }
        | constraint_def=TableConstraintDefinition()
          { action.setAction("ADD_CONSTRAINT");
            action.addElement(constraint_def);
          }
      )
    | <ALTER> [ LOOKAHEAD(2) <SQLCOLUMN> ] col_name=ColumnName()
      (   <SET> default_exp=DoExpression()
          { action.setAction("ALTERSET");
            action.addElement(col_name);
            action.addElement(default_exp);
          }
        | <DROP> <SQLDEFAULT>
          { action.setAction("DROPDEFAULT");
            action.addElement(col_name);
          }
      )
    | <DROP>
      (   [ LOOKAHEAD(2) <SQLCOLUMN> ] col_name=ColumnName()
          { action.setAction("DROP");
            action.addElement(col_name);
          }
        | <CONSTRAINT> con_name=ConstraintName()
          { action.setAction("DROP_CONSTRAINT");
            action.addElement(con_name);
          }
        | <PRIMARY> <KEY>
          { action.setAction("DROP_CONSTRAINT_PRIMARY_KEY");
          }
      )
  )
  
  { return action; }
}



// The list of columns to insert formatted as; eg.  (9, 4), (3, 2), (9, 9), ....
void InsertDataList(ArrayList data_list) :
{ Expression[] exps;
}
{

    "(" exps = ExpressionList() ")" { data_list.add(exps); }
  ( LOOKAHEAD(2) "," "(" exps = ExpressionList() ")" { data_list.add(exps); } )*

}

// Returning true means distinct, false means all.
boolean SetQuantifier() :
{}
{  ( <DISTINCT> { return true; } |
     <ALL>      { return false; } )
}
     

void SelectColumnList(ArrayList list) :
{ SelectColumn col;
}
{
    col = SelectColumn() { list.add(col); }
  ( "," col = SelectColumn() { list.add(col); } )* 

}

SelectColumn SelectColumn() :
{ SelectColumn col = new SelectColumn();
  String aliased_name;
  Token t;
}
{ 
  (   col.expression = DoExpression() [ <AS> ] [ col.alias=TableAliasName() ]
    | <STAR> { col.glob_name = "*"; }
    | t = <GLOBVARIABLE> { col.glob_name = caseCheck(t.image); }
    | t = <QUOTEDGLOBVARIABLE> { col.glob_name = caseCheck(Util.asNonQuotedRef(t)); }
  )
  { return col; }
}

void SelectGroupByList(ArrayList list) :
{ ByColumn col;
  Expression exp;
}
{
    exp = DoExpression() { col = new ByColumn();
                           col.exp = exp;
                           list.add(col); }
  ( "," exp = DoExpression() { col = new ByColumn();
                               col.exp = exp;
                               list.add(col); } )*
  
}

/**
 * NOTE: This is an extension, allows for us to specify a column to return the
 *  max value for each row representing a group.
 */
Variable GroupMaxColumn() :
{ Variable var; }
{
  var = ColumnNameVariable()
  { return var; }
}



void SelectOrderByList(ArrayList list) :
{ ByColumn col;
  Expression exp;
  boolean ascending = true;
}
{
    exp = DoExpression() [ ascending=OrderingSpec() ]
                         { col = new ByColumn();
                           col.exp = exp;
                           col.ascending = ascending;
                           list.add(col); }
  ( "," exp = DoExpression() [ ascending=OrderingSpec() ]
                         { col = new ByColumn();
                           col.exp = exp;
                           col.ascending = ascending;
                           list.add(col); } )*
  
}

boolean OrderingSpec() :
{}
{
  ( <ASC> { return true; } | <DESC> { return false; } )
  
  { return true; }
}


void TableDeclaration(FromClause from_clause) :
{ String table=null, declare_as = null;
  TableSelectExpression select_stmt = null;
}
{

  ( ( table=TableName() | "(" select_stmt=GetTableSelectExpression() ")" )
    [ [ <AS> ] declare_as=TableName() ] )
  
  { from_clause.addTableDeclaration(table, select_stmt, declare_as); }

}

void SelectTableList(FromClause from_clause) :
{}
{
  TableDeclaration(from_clause) [ FromClauseJoin(from_clause) ]
}

void FromClauseJoin(FromClause from_clause) :
{ Expression on_expression; }
{ 
  (
      (
        ","
        { from_clause.addJoin(JoiningSet.INNER_JOIN);}
      ) [ SelectTableList(from_clause) ]
    | (
        [ <INNER> ] <JOIN> TableDeclaration(from_clause) <ON> on_expression=DoExpression()
        { from_clause.addPreviousJoin(JoiningSet.INNER_JOIN, on_expression); }
      ) [ FromClauseJoin(from_clause) ]
    | (
        <LEFT> [<OUTER>] <JOIN> TableDeclaration(from_clause) <ON> on_expression=DoExpression()
        { from_clause.addPreviousJoin(JoiningSet.LEFT_OUTER_JOIN, on_expression); }
      ) [ FromClauseJoin(from_clause) ]
    | (
        <RIGHT> [<OUTER>] <JOIN> TableDeclaration(from_clause) <ON> on_expression=DoExpression()
        { from_clause.addPreviousJoin(JoiningSet.RIGHT_OUTER_JOIN, on_expression); }
      ) [ FromClauseJoin(from_clause) ]
  )

}



String TableName() :
{ Token name;
}
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> |
    name = <DOT_DELIMINATED_REF> | name = <QUOTED_DELIMINATED_REF> )

  { return caseCheck(Util.asNonQuotedRef(name)); }

}

String TriggerName() :
{ Token name;
}
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> )

  { return caseCheck(Util.asNonQuotedRef(name)); }
}

String IndexName() :
{ Token name;
}
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> )

  { return caseCheck(Util.asNonQuotedRef(name)); }
}




// The ' set a = (a * 9), b = concat(b, "aa") ' part of the 'update', 'insert' statement
void AssignmentList(ArrayList assignment_list) :
{ String column;
  Expression exp;
}
{
  ( column=ColumnName() <ASSIGNMENT> exp=DoExpression()
    { assignment_list.add(new Assignment(Variable.resolve(column), exp)); }
    [ "," AssignmentList(assignment_list) ]   
  )
}

// Parses a list of column declarations.  eg. ' id NUMERIC(5, 20), number VARCHAR(90), ... '
// and also any constraints.
void ColumnDeclarationList(ArrayList column_list, ArrayList constraint_list) :
{
}
{
  "(" ColumnOrConstraintDefinition(column_list, constraint_list)
      ( "," ColumnOrConstraintDefinition(column_list, constraint_list) )*
  ")"
}

void ColumnOrConstraintDefinition(ArrayList column_list, ArrayList constraint_list) :
{ ColumnDef coldef = null;
  ConstraintDef condef = null;
}
{
  (   coldef = ColumnDefinition()           { column_list.add(coldef); }
    | condef = TableConstraintDefinition()  { constraint_list.add(condef); }
  )
}

ColumnDef ColumnDefinition() :
{ ColumnDef column = new ColumnDef();
  Token t;
  Token col_constraint;
  Expression default_exp;
  String col_name;
}
{
  ( col_name = ColumnName() { column.setName(col_name); }
    ColumnDataType(column)

    [ <SQLDEFAULT> default_exp = DoExpression() { column.setDefaultExpression(default_exp); } ]
    ( ColumnConstraint(column) )*
    [ ( t=<INDEX_BLIST> | t=<INDEX_NONE> ) { column.setIndex(t); } ] 
  )
  
  { return column; }

}

// Constraint on a column, eg. 'NOT NULL', 'NULL', 'PRIMARY KEY', 'UNIQUE', etc.
void ColumnConstraint(ColumnDef column) :
{ Token t;
  String table_name;
  ArrayList col_list = new ArrayList();
}
{
    (   <NOT> <NULL_LITERAL>  { column.addConstraint("NOT NULL"); }
      | <NULL_LITERAL> { column.addConstraint("NULL"); }
      | <PRIMARY> <KEY> { column.addConstraint("PRIMARY"); }
      | <UNIQUE> { column.addConstraint("UNIQUE"); }
    )
    
//  |
//    (   <REFERENCES> table_name = TableName() [ "(" BasicColumnList(col_list) ")" ]   
//    ) { // Encode the column list in a | deliminated list
//        for (int i = 0; i < col_list.size(); ++i) {
//          table_name += "|" + col_list.get(i).toString();
//        }
//        table_name += "|";
//        column.col.setForeignKey(table_name);
//      }
    

    
}

// Data type of a ColumnDef (eg. "varchar(50)", etc)
void ColumnDataType(ColumnDef column) :
{ String data_type;
  int size = -1;
  int scale = -1;
  Token class_tok = null;
}
{

  (   <JAVA_OBJECT> [ "(" ( class_tok=<DOT_DELIMINATED_REF> | class_tok=<JAVA_OBJECT_ARRAY_REF> ) ")" ]
      { column.setDataType("JAVA_OBJECT", class_tok); } 
  
    | data_type = GetDataType() [ "(" size = PositiveIntegerConstant()
                                  [ "," scale = PositiveIntegerConstant() ] ")" ]

      { column.setDataType(data_type, size, scale); } 

  )
                     
}

String GetDataType() :
{ Token t;
}
{ (   t=<BIT> | t=<INT> | t=<REAL> | t=<BLOB> | t=<CHAR> | t=<TEXT> | t=<DATE> | t=<TIME>
    | t=<FLOAT> | t=<BIGINT> | t=<DOUBLE> | t=<STRING> | t=<BINARY> | t=<NUMERIC> | t=<DECIMAL>
    | t=<BOOLEAN> | t=<TINYINT> | t=<INTEGER> | t=<VARCHAR> | t=<SMALLINT> | t=<VARBINARY>
    | t=<TIMESTAMP> | t=<LONGVARCHAR> | t=<LONGVARBINARY>
  )

  { return t.image; }
}

ConstraintDef TableConstraintDefinition() :
{ ConstraintDef constraint = new ConstraintDef();
  ArrayList column_list = new ArrayList();
  ArrayList column_list2 = new ArrayList();
  String constraint_name;
  String update_rule = "NO ACTION";
  String delete_rule = "NO ACTION";
  Expression expression;
  String name;
  String reference_table;
  Token t;
}
{
  ( [ <CONSTRAINT> constraint_name = ConstraintName() { constraint.setName(constraint_name); }  ]

    (   <PRIMARY> <KEY> "(" BasicColumnList(column_list) ")" { constraint.setPrimaryKey(column_list); }
      | <UNIQUE> "(" BasicColumnList(column_list) ")"      { constraint.setUnique(column_list); }
      | <CHECK> "(" expression = DoExpression() ")"        { constraint.setCheck(expression); }
      | <FOREIGN> <KEY> "(" BasicColumnList(column_list) ")"
        <REFERENCES> reference_table=TableName() [ "(" BasicColumnList(column_list2) ")" ]
        [   LOOKAHEAD(2) ( <ON> <DELETE> delete_rule=ReferentialTrigger()
              [ <ON> <UPDATE> update_rule=ReferentialTrigger() ]
            )
          | ( <ON> <UPDATE> update_rule=ReferentialTrigger()
              [ <ON> <DELETE> delete_rule=ReferentialTrigger() ]
            )
        ]
        { constraint.setForeignKey(reference_table, column_list, column_list2, delete_rule, update_rule); }
    )

    // Constraint deferrability
    [ ConstraintAttributes(constraint) ]
   
  )
  
  { return constraint; }

}

String ReferentialTrigger() :
{ Token t;
}
{
  ( t=<NO_ACTION> | t=<CASCADE> | t=<SET_NULL> | t=<SET_DEFAULT> )

  { return t.image; }
}

void ConstraintAttributes(ConstraintDef constraint) :
{
}
{
  (   (
        <INITIALLY> (   <DEFERRED>  { constraint.setInitiallyDeferred(); }
                      | <IMMEDIATE>
                    )

        [   <NOT> <DEFERRABLE>  { constraint.setNotDeferrable(); }
          | <DEFERRABLE>
        ]
      )
    |
      (
        ( <NOT> <DEFERRABLE>  { constraint.setNotDeferrable(); } | <DEFERRABLE> )
        [ <INITIALLY> (   <DEFERRED>  { constraint.setInitiallyDeferred(); }
                        | <IMMEDIATE>
                      )
        ]
      )
  )
}



// A list of column names
void BasicColumnList(ArrayList list) :
{ String col_name;
}
{
        col_name = ColumnName() { list.add(col_name); }
  ( "," col_name = ColumnName() { list.add(col_name); } )*
}







void ConditionsExpression(SearchExpression se) :
{ Expression exp; }
{
  exp = DoExpression()

  { se.setFromExpression(exp); }
}


//
//void ConditionsExpression(ConditionTree cs) :
//{ Token logical; }
//{
//  
//  Conditional(cs) (
//    LOOKAHEAD(3) ( logical = <AND> | logical = <OR> )  { cs.addLogical(logical.image); }
//    Conditional(cs) )*
//
//}
//


//
//void Conditional(ConditionTree cs) :
//{ Expression exp; }
//{
////  (  c = Comparison()  { cs.addCondition(c); }
////    | "(" ConditionsExpression(cs.addConditionTree()) ")" )
//
//  (  LOOKAHEAD(5) exp = DoExpression()  { cs.addExpression(exp); }
//    | "(" ConditionsExpression(cs.addConditionTree()) ")" )
//    
//}
//




Expression ExpressionTest() :
{ Expression exp; }
{
  exp=DoExpression() ";"

  { return exp; }
}  

Expression DoExpression() :
{ Stack stack = new Stack();
  Expression exp = new Expression();
}
{

  expression(exp, stack)

  { expEnd(exp, stack);
    // Normalize the expression (remove any NOT operators)
    Expression normalized_exp = Util.normalize(exp);
    normalized_exp.copyTextFrom(exp);
    return normalized_exp;
  }
}

Expression DoNonBooleanExpression() :
{ Stack stack = new Stack();
  Expression exp = new Expression();
}
{

  nonBooleanExpression(exp, stack)

  { expEnd(exp, stack);
    return exp; }
}


/**
 * Parse an expression.
 */
void expression(Expression exp, Stack stack) :
{ 
}
{

  Operand(exp, stack) ( LOOKAHEAD(2) OpPart(exp, stack) )*

}

/**
 * Parses a non-boolean expression.
 */
void nonBooleanExpression(Expression exp, Stack stack) :
{
}
{
  
  Operand(exp, stack) ( LOOKAHEAD(2) NumericOperator(exp, stack) Operand(exp, stack) )* 

}

void OpPart(Expression exp, Stack stack) :
{ Token t;
//  SelectStatement select;
//  Expression[] exp_arr;
  Expression regex_expression;
  Object regex_ob;
  
}
{

  (   LOOKAHEAD(3) ( BooleanOperator(exp, stack) | NumericOperator(exp, stack) )
                   Operand(exp, stack)

    | LOOKAHEAD(2) <IS> <NULL_LITERAL>
      { expOperator(exp, stack, Operator.get("=")); exp.addElement(null);
        exp.text().append(" is null"); }
          
    | LOOKAHEAD(3) <IS> <NOT> <NULL_LITERAL>
      { expOperator(exp, stack, Operator.get("<>")); exp.addElement(null);
        exp.text().append(" is not null"); }

      // NOTE: Handling regex literals is a horrible horrible hack.  The <REGEX_LITERAL> 
      //   token starts with 'regex /' and the regex string follows.
    | (   <REGEX> { exp.text().append(" regex ");
                                 expOperator(exp, stack, Operator.get("regex"));
                               }
                               expression(exp, stack)
                     | t=<REGEX_LITERAL>
                        { regex_ob = Util.toParamObject(t, case_insensitive_identifiers);
                          exp.text().append(" regex " + regex_ob);
                          expOperator(exp, stack, Operator.get("regex"));
                          exp.addElement(regex_ob);
                        }
                   )

//    | ( t=<IN> | t=<NOTIN> ) "("
//        (   select=Select()
//            { expOperator(exp, stack, Operator.get(t.image)); exp.addElement(select);
//              exp.text().append(" " + t.image + " [SELECT]"); }
//          | exp_arr = ExpressionList()
//            { expOperator(exp, stack, Operator.get(t.image)); exp.addElement(exp_arr);
//              exp.text().append(" " + t.image + " ( " + Util.expressionListToString(exp_arr) + " )");
//            }
//
//        ) ")"
                   
    | LOOKAHEAD(2) SubQueryOperator(exp, stack) SubQueryExpression(exp, stack) 

    | BetweenPredicate(exp, stack) 

  )
  
}  
  

void Operand(Expression exp, Stack stack) :
{ Token t, tt;
  FunctionDef f;
  String time_fname;
}
{
  (   "(" { stack.push(Operator.get("(")); exp.text().append("("); }
        expression(exp, stack) ")" { expEndParen(exp, stack); exp.text().append(")"); }
    | t = <PARAMETER_REF>
          { Object param_resolve = createSubstitution(t.image); 
            exp.addElement(param_resolve);
            exp.text().append('?');
          }

    | LOOKAHEAD(2) <NOT>
      { expOperator(exp, stack, Operator.get("not"));
        exp.text().append(" not ");
      }
      Operand(exp, stack)
          
    | LOOKAHEAD(3) ( f = Function()
          { exp.addElement(f); exp.text().append(f); }
      ) 

// Time values
| ( (   tt=<DATE> { time_fname="DATEOB"; }
      | tt=<TIME> { time_fname="TIMEOB"; } 
      | tt=<TIMESTAMP> { time_fname="TIMESTAMPOB"; }
    )
    t=<STRING_LITERAL>
    { Object param_ob1 = Util.toParamObject(t, case_insensitive_identifiers);
      Expression[] exp_list = new Expression[] { new Expression(param_ob1) };
      f = Util.resolveFunctionName(time_fname, exp_list);
      exp.addElement(f);
      exp.text().append(tt.image).append(" ").append(t.image);
    }
  )
      
      
// Java object instantiation
    | ( <NEW> f = JavaInstantiation()
          { exp.addElement(f); exp.text().append(f); }
      )
          
    | (   t=<STRING_LITERAL>
        | t=<NUMBER_LITERAL>
        | t=<BOOLEAN_LITERAL>
        | t=<NULL_LITERAL>
        | t=<QUOTED_VARIABLE>
        | t=<DOT_DELIMINATED_REF>    // (eg. 're1.re2.id')
        | t=<QUOTED_DELIMINATED_REF> // (eg. '"re1"."re2"."id"')
        | t=<IDENTIFIER>
      ) { Object param_ob = Util.toParamObject(t, case_insensitive_identifiers); 
          exp.addElement(param_ob);
          exp.text().append(t.image);
//          if (t.kind == SQLConstants.STRING_LITERAL) exp.text().append("'" + param_ob + "'");
//          else exp.text().append(param_ob);
        }

  )

}

void SubQueryExpression(Expression exp, Stack stack) :
{ TableSelectExpression select;
  Expression[] exp_arr;
}
{
  // Parse the subquery list (either a list or a select statement)
  "("
  (   select=GetTableSelectExpression()
      { exp.addElement(select);
        exp.text().append(" [SELECT]"); }
    | exp_arr=ExpressionList()
      { exp.addElement(exp_arr);
        exp.text().append(" (" + Util.expressionListToString(exp_arr) + ")");
      }
  )
  ")"
}

/*
// Parse a sub query expression.  For example,
// IN ( SELECT ... ), > ANY ( SELECT .... )
void SubQueryExpression(Expression exp, Stack stack) :
{ Token t = null, aat = null;
  String comparison_op = null;
  SelectStatement select;
  Expression[] exp_arr;
  Operator op;
}
{
  // Parse IN, NOT IN, (comparison) ANY, (comparison) ALL forms
  (   t=<IN> | t=<NOTIN>
    | comparison_op=GetComparisonOperator() ( aat=<ANY> | aat=<ALL> | aat=<SOME> )
  )
    { if (t != null) {
        op = Operator.get(t.image);
      }
      else {
        String sq_form = "SINGLE";
        if (aat != null) {
          sq_form = aat.image;
        }
        op = Operator.get(comparison_op).getSubQueryForm(sq_form);
      }
    }
  // Parse the subquery list (either a list or a select statement)
  "("
  (   select=Select()
      { expOperator(exp, stack, op); exp.addElement(select);
        exp.text().append(" " + op.toString() + " [SELECT]"); }
    | exp_arr=ExpressionList()
      { expOperator(exp, stack, op); exp.addElement(exp_arr);
        exp.text().append(" " + t.image + " ( " + Util.expressionListToString(exp_arr) + " )");
      }
  )
  ")"
}
*/

// Parses a simple positive integer constant.
int PositiveIntegerConstant() :
{ Token t;
}
{
  t = <NUMBER_LITERAL>

  { int val = Integer.parseInt(t.image);
    if (val < 0) generateParseException();
    return val;
  }
}


void SubQueryOperator(Expression exp, Stack stack) :
{ Token t;
  String op_string;
  String query_type = "SINGLE";
  Operator op;
}
{
  (   LOOKAHEAD(2) (   <IN> { op = Operator.get("IN"); }
                     | <NOT> <IN> { op = Operator.get("NOT IN"); }
      )
  
    | (  op_string = GetSubQueryBooleanOperator() { op = Operator.get(op_string); }
    [ ( t=<ANY> | t=<ALL> | t=<SOME> ) { query_type=t.image; } ]
    { op = op.getSubQueryForm(query_type);
    }
      )
  )

  { expOperator(exp, stack, op);
    exp.text().append(" " + op + " ");
  }          
  
}

void BetweenPredicate(Expression exp, Stack stack) :
{ boolean not_s = false;
  Expression exp1, exp2;
}
{   [ <NOT> { not_s = true; } ] <BETWEEN>
           exp1=DoNonBooleanExpression() <AND> exp2=DoNonBooleanExpression()

  { //Expression[] exp_list = new Expression[] { exp1, exp2 };
    //Operator op;
    //if (not_s) {
    //  op = Operator.get("not between");
    //  exp.text().append(" not between ");
    //}
    //else {
    //  op = Operator.get("between");
    //  exp.text().append(" between ");
    //}
    //expOperator(exp, stack, op);
    //exp.addElement(exp_list);
    //exp.text().append(exp1.text().toString());
    //exp.text().append(" and ");
    //exp.text().append(exp2.text().toString());

    // Flush the operator stack to precedence 8
    flushOperatorStack(exp, stack, 8);
    // Get the end expression
    Expression end_exp = exp.getEndExpression();
    if (not_s) {
      exp.concat(exp1);
      exp.addElement(Operator.get("<"));
      exp.concat(end_exp);
      exp.concat(exp2);
      exp.addElement(Operator.get(">"));
      exp.addElement(Operator.get("or"));
      exp.text().append(" not between ");
    }
    else {
      exp.concat(exp1);
      exp.addElement(Operator.get(">="));
      exp.concat(end_exp);
      exp.concat(exp2);
      exp.addElement(Operator.get("<="));
      exp.addElement(Operator.get("and"));
      exp.text().append(" between ");
    }
    exp.text().append(exp1.text().toString());
    exp.text().append(" and ");
    exp.text().append(exp2.text().toString());

  }

}

void BooleanOperator(Expression exp, Stack stack) :
{ Token t;
  String op_string;
  Operator op;
}
{
  (   op_string = GetBooleanOperator() { op = Operator.get(op_string); }
  )

  { expOperator(exp, stack, op);
    exp.text().append(" " + op + " ");
  }          
}

void NumericOperator(Expression exp, Stack stack) :
{ Token t;
  String op_string;
  Operator op;
}
{
  (   op_string = GetNumericOperator() { op = Operator.get(op_string); }
  )

  { expOperator(exp, stack, op);
    exp.text().append(" " + op + " ");
  }          
}

String GetBooleanOperator() :
{ Token t;
}
{
  (   t=<ASSIGNMENT> | t=<EQUALS> | t=<GR> | t=<LE> | t=<GREQ> | t=<LEEQ>
    | t=<NOTEQ> | t=<LIKE> | <NOT> <LIKE> { return "NOT LIKE"; } | t=<AND> | t=<OR>
  )
  { return t.image; }
}

String GetSubQueryBooleanOperator() :
{ Token t;
}
{
  (   t=<ASSIGNMENT> | t=<EQUALS> | t=<GR> | t=<LE> | t=<GREQ> | t=<LEEQ> | t=<NOTEQ>
  )
  { return t.image; }
}

String GetNumericOperator() :
{ Token t;
}
{
   (   t=<DIVIDE> | t=<ADD> | t=<SUBTRACT>
     | t=<STAR>   // This is "*" (multiply) 
   )
   { return t.image; }
}
  
/*
String GetOperator() :
{ Token t;
}
{
   (   t=<ASSIGNMENT> | t=<EQUALS> | t=<GR> | t=<LE> | t=<GREQ> | t=<LEEQ> | t=<NOTEQ>
     | t=<DIVIDE> | t=<ADD> | t=<SUBTRACT> | t=<LIKE> | t=<NOTLIKE> | t=<AND>
     | t=<OR>
     | t=<STAR>   // This is "*" (multiply) 
   )
   { return t.image; }
}
*/

FunctionDef Function() :
{ Token t, t2 = null, t3 = null;
  FunctionDef f;
  Expression exp1, exp2;
  Expression[] exp_list;
}
{
  ( // COUNT function requires special handling,
      ( t = <COUNT> "(" [ <DISTINCT> { t.image="distinct_count"; } ] exp_list = FunctionParams() ")" )
    // TRIM function  
    | ( t = <TRIM> "(" [ LOOKAHEAD(3) [ t2=<LEADING> | t2=<BOTH> | t2=<TRAILING> ]
                         [ t3=<STRING_LITERAL> ] <FROM> ] exp1=DoExpression() ")" ) 
                        { exp_list = new Expression[3];
                          String ttype = t2 == null ? "both" : t2.image.toLowerCase();
                          Object str_char = t3 == null ? " " : Util.toParamObject(t3, case_insensitive_identifiers);
                          exp_list[0] = new Expression(ttype);
                          exp_list[0].text().append("'" + ttype + "'");
                          exp_list[1] = new Expression(str_char);
                          exp_list[1].text().append("'" + str_char + "'");
                          exp_list[2] = exp1;
                          return Util.resolveFunctionName("sql_trim", exp_list);
                        }
    // IF function
    | ( t = <IF> "(" exp_list = FunctionParams() ")" )
    // Standard functions.
    | ( t = <IDENTIFIER> "(" exp_list = FunctionParams() ")" )
  )

  { return Util.resolveFunctionName(t.image, exp_list); }  
}

// An instantiation of a java object.  For example, 'java.awt.Point(40, 30)'
FunctionDef JavaInstantiation() :
{ Token t;
  Expression[] args;
}
{
  // PENDING: Handling arrays (eg. 'java.lang.String[] { 'Tobias', 'Downer' }' or 'double[] { 25, 2, 75, 26 }' )
  t=<DOT_DELIMINATED_REF> "(" args=ExpressionList() ")"
  
  { Expression[] comp_args = new Expression[args.length + 1];
    System.arraycopy(args, 0, comp_args, 1, args.length);
    comp_args[0] = new Expression(t.image);
    comp_args[0].text().append("'" + t.image + "'");
    return Util.resolveFunctionName("_new_JavaObject", comp_args); }
}

// Parameters for a function
Expression[] FunctionParams() :
{ Expression[] exp_list;
}
{
  ( <STAR> { exp_list = FunctionFactory.GLOB_LIST; }
    | exp_list = ExpressionList()
  )
  
  { return exp_list; }
}




Expression[] ExpressionList() :
{ ArrayList list = new ArrayList();
  Expression e;
}
{
  [ e = DoExpression() { list.add(e); }
    ( "," e = DoExpression() { list.add(e); }  )*
  ]
  
  { return (Expression[]) list.toArray(new Expression[list.size()]); }
}


String GetComposite() :
{ Token name; }
{
  ( name = <UNION> | name = <INTERSECT> | name = <EXCEPT> )
  
  { return name.image; }
}

// Name of a schema
String SchemaName() :
{ Token name; }
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> )
  
  { return caseCheck(Util.asNonQuotedRef(name)); }
}

// Name of a constraint name
String ConstraintName() :
{ Token name; }
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> )
  
  { return caseCheck(Util.asNonQuotedRef(name)); }
}

// Parses a column name  
String ColumnName() :
{ Token name; }
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> |
    name = <DOT_DELIMINATED_REF> | name = <QUOTED_DELIMINATED_REF> )

  { return caseCheck(Util.asNonQuotedRef(name)); }
}

// Parses a column name as a Variable object  
Variable ColumnNameVariable() :
{ Token name; }
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> |
    name = <DOT_DELIMINATED_REF> | name = <QUOTED_DELIMINATED_REF> )

  { return (Variable) Util.toParamObject(name, case_insensitive_identifiers); } 
}

// Parses an aliased table name  
String TableAliasName() :
{ Token name; }
{
  ( name = <QUOTED_VARIABLE> | name = <IDENTIFIER> )

  { return caseCheck(Util.asNonQuotedRef(name)); }
}

























