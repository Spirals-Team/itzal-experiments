/* Generated By:JavaCC: Do not edit this line. SQL.java */
package com.mckoi.database.sql;

import com.mckoi.database.Assignment;
import com.mckoi.database.JoiningSet;
import com.mckoi.database.Expression;
import com.mckoi.database.Variable;
import com.mckoi.database.FunctionDef;
import com.mckoi.database.FunctionFactory;
import com.mckoi.database.Operator;
import com.mckoi.database.StatementTree;
import com.mckoi.database.ParameterSubstitution;
import com.mckoi.database.global.*;
import com.mckoi.database.interpret.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Stack;

public class SQL implements SQLConstants {

  // State variables for the parser,

  /**
   * Set to true if the SQL identifiers are converted to upper case.
   * NOTE: Purely experimental feature!
   */
  private boolean case_insensitive_identifiers = false;

  /**
   * The parameter id.
   */
  private int parameter_id = 0;


  /**
   * Resets the parameter id.  This MUST be called before a parser is used
   * to parse a statement.
   */
  public void reset() {
    parameter_id = 0;
  }

  /**
   * Creates and returns a parameter substitution.  This is called when the
   * parser comes across a '?' style object.  This object is used to mark an
   * expression with a place mark that can be substituted for a value later.
   */
  public ParameterSubstitution createSubstitution(String image) {
    ParameterSubstitution ps = new ParameterSubstitution(parameter_id);
    ++parameter_id;
    return ps;
  }


//  /**
//   * The parameters that we have passed into the SQL statement.
//   */
//  Object[] params = new Object[0];
//  int parameter_index = -1;

//  /**
//   * Sets the parameters for this SQL parser.
//   */
//  public void setParameters(Object[] params) {
//    this.params = params;
//    for (int i = 0; i < params.length; ++i) {
//      if (params[i] == null) {
//        params[i] = NullObject.NULL_OBJ;
//      }
//    }
//    parameter_index = -1;
//  }

//  /**
//   * Returns the next parameter.  This is called when a '?' type parameter
//   * reference is seen.
//   */
//  public Object nextParameter() {
//    ++parameter_index;
//    return params[parameter_index];
//  }

//  /**
//   * Converts the parameter string (eg. "%3", or "?") to the parameter
//   * argument that was passed into the statement (eg. params[3] or the
//   * next parameter in the case of "?").
//   */
//  public Object getParameter(String param_ref) {
//    if (param_ref.equals("?")) {
//      return nextParameter();
//    }
//    else if (param_ref.startsWith("%")) {
//      int i = Integer.parseInt(param_ref.substring(1));
//      if (i >= 0 && i < params.length) {
//        return params[i];
//      }
//      else {
//        throw new Error("Param reference out of range.");
//      }
//    }
//    throw new Error("Error, parameter string incorrect.");
//  }

//  /**
//   * Used to toggle whether this parser uses case insensitive
//   * identifiers or not.  If this is set to true, call identifiers
//   * are made lower case.  This is false by default.
//   */
//  public void setCaseInsensitiveIdentifiers(boolean case_insensitive) {
//    case_insensitive_identifiers = case_insensitive;
//  }

  /**
   * If the parser has been defined as case insensitive then this
   * returns the uppercase version of the given string.
   */
  public String caseCheck(String identif) {
//    if (case_insensitive_identifiers) {
//      return identif.toUpperCase();
//    }
    return identif;
  }

  /**
   * Helper for expression parsing.
   * Called when an end parenthese has been found.
   */
  public void expEndParen(Expression exp, Stack stack) {
    Operator op = (Operator) stack.pop();
    while (!op.is("(")) {
      addOperatorToExpression(exp, op);
      op = (Operator) stack.pop();
    }
  }

  /**
   * Helper for expression parsing.
   * Called when an operator has been read in.  This needs to check precedence
   * and add the operator to the expression as appropriate.
   */
  public void expOperator(Expression exp, Stack stack, Operator op) {
    int precedence = op.precedence();
    flushOperatorStack(exp, stack, precedence);
    stack.push(op);
  }

  /**
   * Flush the operator stack until the stack is either empty or the top
   * element is either a "(" or of a precedence lower than the given
   * precedence.
   */
  public void flushOperatorStack(Expression exp, Stack stack, int precedence) {
    if (!stack.empty()) {
      Operator top_op = (Operator) stack.pop();
      while (!top_op.is("(") && top_op.precedence() > precedence) {
        addOperatorToExpression(exp, top_op);
        if (stack.empty()) {
          return;
        }
        top_op = (Operator) stack.pop();
      }
      stack.push(top_op);
    }
  }

  /**
   * Helper for expression parsing.
   * Called when an entire expression has been read in.  We need to empty
   * the stack.
   */
  public void expEnd(Expression exp, Stack stack) {
    while (!stack.empty()) {
      Operator op = (Operator) stack.pop();
      addOperatorToExpression(exp, op);
    }
  }

  /**
   * Helper for expression parsing.
   * Adds an operator to the given expression.
   */
  public void addOperatorToExpression(Expression exp, Operator op) {
    if (op.is("not")) {
      exp.addElement(null);
    }
    exp.addOperator(op);
  }



//  public static void printExpressionList(Expression[] exp_arr) {
//    System.out.println(exp_arr);
//    for (int p = 0; p < exp_arr.length; ++p) {
//      System.out.println(exp_arr[p]);
//    }
//  }


  public static void main(String args[]) throws ParseException {
    SQL parser = new SQL(System.in);
    parser.Test();
  }

  final public void Test() throws ParseException {
    parseExpression();
    jj_consume_token(153);

  }

// Parses a single expression.  Useed in 'com.mckoi.database.Expression.parse' method.
  final public Expression parseExpression() throws ParseException {
  Expression exp;
    exp = DoExpression();
    jj_consume_token(0);
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

// Statement that ends with a ';'
  final public StatementTree Statement() throws ParseException {
  StatementTree ob;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      ob = Select();
      break;
    case UPDATE:
      ob = Update();
      break;
    case ALTER:
      ob = Alter();
      break;
    case COMPACT:
      ob = Compact();
      break;
    case CREATE:
      ob = Create();
      break;
    case DROP:
      ob = Drop();
      break;
    case DELETE:
      ob = Delete();
      break;
    case INSERT:
      ob = Insert();
      break;
    case DESCRIBE:
      ob = Describe();
      break;
    case SHOW:
      ob = Show();
      break;
    case COMMIT:
    case ROLLBACK:
      ob = CompleteTransaction();
      break;
    case SET:
      ob = Set();
      break;
    case SHUTDOWN:
      ob = ShutDown();
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 153:
      jj_consume_token(153);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return ob;}
    throw new Error("Missing return statement in function");
  }

// All statements that start with <CREATE>
  final public StatementTree Create() throws ParseException {
  StatementTree ob;
    jj_consume_token(CREATE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TABLE:
    case TEMPORARY:
      ob = CreateTable();
      break;
    case TRIGGER:
      ob = CreateTrigger();
      break;
    case INDEX:
    case UNIQUE:
      ob = CreateIndex();
      break;
    case SCHEMA:
      ob = CreateSchema();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return ob;}
    throw new Error("Missing return statement in function");
  }

// All statements that start with <DROP>
  final public StatementTree Drop() throws ParseException {
  StatementTree ob;
    jj_consume_token(DROP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TABLE:
      ob = DropTable();
      break;
    case TRIGGER:
      ob = DropTrigger();
      break;
    case INDEX:
      ob = DropIndex();
      break;
    case SCHEMA:
      ob = DropSchema();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return ob;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Select() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Select");
  TableSelectExpression table_expr;
  ArrayList order_by = new ArrayList();
    table_expr = GetTableSelectExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDERBY:
      jj_consume_token(ORDERBY);
      SelectOrderByList(order_by);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    cmd.putObject("table_expression", table_expr);
    cmd.putObject("order_by", order_by);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Update() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.UpdateTable");
  String table_name;
  ArrayList assignments = new ArrayList();
  SearchExpression where_clause = new SearchExpression();
  int limit = -1;
    jj_consume_token(UPDATE);
    table_name = TableName();
    jj_consume_token(SET);
    AssignmentList(assignments);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      ConditionsExpression(where_clause);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIMIT:
      jj_consume_token(LIMIT);
      limit = PositiveIntegerConstant();
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    cmd.putObject("table_name", table_name);
    cmd.putObject("assignments", assignments);
    cmd.putObject("where_clause", where_clause);
    cmd.putInt("limit", limit);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Alter() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.AlterTable");
  String table_name;
  AlterTableAction action;
  StatementTree create_statement;
    if (jj_2_1(2)) {
      jj_consume_token(ALTER);
      jj_consume_token(TABLE);
      table_name = TableName();
      action = GetAlterTableAction();
        cmd.putObject("table_name", table_name);
        cmd.putObject("alter_action", action);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALTER:
        jj_consume_token(ALTER);
        jj_consume_token(CREATE);
        create_statement = CreateTable();
        cmd.putObject("create_statement", create_statement);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Compact() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Compact");
  String table_name;
    jj_consume_token(COMPACT);
    jj_consume_token(TABLE);
    table_name = TableName();
    cmd.putObject("table_name", table_name);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree CreateTable() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CreateTable");
  boolean temporary = false;
  boolean only_if_not_exists = false;
  String table_name;
  ArrayList column_list = new ArrayList();
  ArrayList constraint_list = new ArrayList();
  Expression check_expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEMPORARY:
      jj_consume_token(TEMPORARY);
                     temporary = true;
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(TABLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(NOT);
      jj_consume_token(EXISTS);
                             only_if_not_exists = true;
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    table_name = TableName();
    ColumnDeclarationList(column_list, constraint_list);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHECK:
      jj_consume_token(CHECK);
      check_expression = DoExpression();
              ConstraintDef check_constraint = new ConstraintDef();
              check_constraint.setCheck(check_expression);
              constraint_list.add(check_constraint);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    cmd.putBoolean("temporary", temporary);
    cmd.putBoolean("only_if_not_exists", only_if_not_exists);
    cmd.putObject("table_name", table_name);
    cmd.putObject("column_list", column_list);
    cmd.putObject("constraint_list", constraint_list);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree CreateTrigger() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CreateTrigger");
  String trigger_name;
  String type;
  String table_name;
    jj_consume_token(TRIGGER);
    trigger_name = TriggerName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSERT:
      jj_consume_token(INSERT);
                            type = "INSERT";
      break;
    case UPDATE:
      jj_consume_token(UPDATE);
                            type = "UPDATE";
      break;
    case DELETE:
      jj_consume_token(DELETE);
                            type = "DELETE";
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(ON);
    table_name = TableName();
    cmd.putObject("trigger_name", trigger_name);
    cmd.putObject("type", type);
    cmd.putObject("table_name", table_name);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree DropTrigger() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.DropTrigger");
  String trigger_name;
    jj_consume_token(TRIGGER);
    trigger_name = TriggerName();
    cmd.putObject("trigger_name", trigger_name);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree CreateSchema() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Schema");
  cmd.putObject("type", "create");
  String schema_name;
    jj_consume_token(SCHEMA);
    schema_name = SchemaName();
    cmd.putObject("schema_name", schema_name);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree DropSchema() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Schema");
  cmd.putObject("type", "drop");
  String schema_name;
    jj_consume_token(SCHEMA);
    schema_name = SchemaName();
    cmd.putObject("schema_name", schema_name);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree CreateView() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CreateView");
  String view_name;
  TableSelectExpression select_statement;
    jj_consume_token(VIEW);
    view_name = TableName();
    select_statement = GetTableSelectExpression();
    cmd.putObject("view_name", view_name);
    cmd.putObject("select_statement", select_statement);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree CreateIndex() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.NoOp");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNIQUE:
      jj_consume_token(UNIQUE);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(INDEX);
    IndexName();
    jj_consume_token(ON);
    TableName();
    jj_consume_token(154);
    BasicColumnList(new ArrayList());
    jj_consume_token(155);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree DropTable() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.DropTable");
  boolean only_if_exists = false;
  String table_name;
  ArrayList table_list = new ArrayList();
    jj_consume_token(TABLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(EXISTS);
                           only_if_exists = true;
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    table_name = TableName();
                                    table_list.add(table_name);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 156:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_1;
      }
      jj_consume_token(156);
      table_name = TableName();
                                            table_list.add(table_name);
    }
    cmd.putBoolean("only_if_exists", only_if_exists);
    cmd.putObject("table_list", table_list);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree DropIndex() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.NoOp");
    jj_consume_token(INDEX);
    IndexName();
    jj_consume_token(ON);
    TableName();
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Delete() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Delete");
  String table_name;
  SearchExpression where_clause = new SearchExpression();
  int limit = -1;
    jj_consume_token(DELETE);
    jj_consume_token(FROM);
    table_name = TableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      ConditionsExpression(where_clause);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIMIT:
      jj_consume_token(LIMIT);
      limit = PositiveIntegerConstant();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    cmd.putObject("table_name", table_name);
    cmd.putObject("where_clause", where_clause);
    cmd.putInt("limit", limit);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Insert() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Insert");
  String table_name;
  ArrayList col_list = new ArrayList();
  ArrayList data_list = new ArrayList(); // ( Array of Expression[] )
  StatementTree select = null;
  ArrayList assignments = new ArrayList();
  String type;
    jj_consume_token(INSERT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTO:
      jj_consume_token(INTO);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    table_name = TableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
    case VALUES:
    case 154:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 154:
        jj_consume_token(154);
        BasicColumnList(col_list);
        jj_consume_token(155);
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VALUES:
        jj_consume_token(VALUES);
        InsertDataList(data_list);
                                                     type = "from_values";
        break;
      case SELECT:
        select = Select();
                                                     type = "from_select";
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case SET:
      jj_consume_token(SET);
      AssignmentList(assignments);
                                                     type = "from_set";
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    cmd.putObject("table_name", table_name);
    cmd.putObject("col_list", col_list);
    cmd.putObject("data_list", data_list);
    cmd.putObject("select", select);
    cmd.putObject("assignments", assignments);
    cmd.putObject("type", type);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Describe() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Show");
  cmd.putObject("show", "describe_table");
  String table_name;
    jj_consume_token(DESCRIBE);
    table_name = TableName();
    cmd.putObject("table_name", table_name);
    cmd.putObject("where_clause", new SearchExpression());
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Show() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Show");
  Expression[] args = null;
  SearchExpression where_clause = new SearchExpression();
  Token t;
    jj_consume_token(SHOW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      break;
    case SCHEMA:
      t = jj_consume_token(SCHEMA);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 154:
      jj_consume_token(154);
      args = ExpressionList();
      jj_consume_token(155);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      ConditionsExpression(where_clause);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    cmd.putObject("show", t.image);
    cmd.putObject("args", args);
    cmd.putObject("where_clause", where_clause);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree CompleteTransaction() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.CompleteTransaction");
  String command;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMIT:
      jj_consume_token(COMMIT);
                   command = "commit";
      break;
    case ROLLBACK:
      jj_consume_token(ROLLBACK);
                   command = "rollback";
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    cmd.putObject("command", command);
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree Set() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Set");
  Token t1;
  String value;
  Expression exp;
  String name;
    jj_consume_token(SET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t1 = jj_consume_token(IDENTIFIER);
      jj_consume_token(ASSIGNMENT);
      exp = DoExpression();
          cmd.putObject("type", "VARSET");
          cmd.putObject("var_name", t1.image);
          cmd.putObject("exp", exp);
      break;
    case TRANSACTIONISOLATIONLEVEL:
      jj_consume_token(TRANSACTIONISOLATIONLEVEL);
      t1 = jj_consume_token(SERIALIZABLE);
          cmd.putObject("type", "ISOLATIONSET");
          cmd.putObject("var_name", "TRANSACTION ISOLATION LEVEL");
          cmd.putObject("value", t1.image);
      break;
    case AUTOCOMMIT:
      jj_consume_token(AUTOCOMMIT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ON:
        t1 = jj_consume_token(ON);
        break;
      case IDENTIFIER:
        t1 = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          cmd.putObject("type", "AUTOCOMMIT");
          cmd.putObject("value", t1.image);
      break;
    case SCHEMA:
      jj_consume_token(SCHEMA);
      name = SchemaName();
          cmd.putObject("type", "SCHEMA");
          cmd.putObject("value", name);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public StatementTree ShutDown() throws ParseException {
  StatementTree cmd = new StatementTree("com.mckoi.database.interpret.Misc");
    jj_consume_token(SHUTDOWN);
    cmd.putObject("command", "shutdown");
    {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

// ----------

// A table expression 
  final public TableSelectExpression GetTableSelectExpression() throws ParseException {
  TableSelectExpression table_expr = new TableSelectExpression();
  String composite = "";
  boolean is_all = false;
  TableSelectExpression next_composite_expression;
    jj_consume_token(SELECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
    case DISTINCT:
      table_expr.distinct = SetQuantifier();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    SelectColumnList(table_expr.columns);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FROM:
      jj_consume_token(FROM);
      SelectTableList(table_expr.from_clause);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      jj_consume_token(WHERE);
      ConditionsExpression(table_expr.where_clause);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUPBY:
      jj_consume_token(GROUPBY);
      SelectGroupByList(table_expr.group_by);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUPMAX:
        jj_consume_token(GROUPMAX);
        table_expr.group_max = GroupMaxColumn();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HAVING:
        jj_consume_token(HAVING);
        ConditionsExpression(table_expr.having_clause);
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNION:
    case EXCEPT:
    case INTERSECT:
      composite = GetComposite();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
        jj_consume_token(ALL);
                                               is_all = true;
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      next_composite_expression = GetTableSelectExpression();
            table_expr.chainComposite(next_composite_expression, composite, is_all);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    {if (true) return table_expr;}
    throw new Error("Missing return statement in function");
  }

  final public AlterTableAction GetAlterTableAction() throws ParseException {
  String col_name, con_name;
  ColumnDef column_def;
  ConstraintDef constraint_def;
  Expression default_exp;
  AlterTableAction action = new AlterTableAction();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQLADD:
      jj_consume_token(SQLADD);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQLCOLUMN:
      case QUOTED_VARIABLE:
      case IDENTIFIER:
      case DOT_DELIMINATED_REF:
      case QUOTED_DELIMINATED_REF:
        if (jj_2_2(2)) {
          jj_consume_token(SQLCOLUMN);
        } else {
          ;
        }
        column_def = ColumnDefinition();
            action.setAction("ADD");
            action.addElement(column_def);
        break;
      case CHECK:
      case UNIQUE:
      case CONSTRAINT:
      case PRIMARY:
      case FOREIGN:
        constraint_def = TableConstraintDefinition();
            action.setAction("ADD_CONSTRAINT");
            action.addElement(constraint_def);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case ALTER:
      jj_consume_token(ALTER);
      if (jj_2_3(2)) {
        jj_consume_token(SQLCOLUMN);
      } else {
        ;
      }
      col_name = ColumnName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SET:
        jj_consume_token(SET);
        default_exp = DoExpression();
            action.setAction("ALTERSET");
            action.addElement(col_name);
            action.addElement(default_exp);
        break;
      case DROP:
        jj_consume_token(DROP);
        jj_consume_token(SQLDEFAULT);
            action.setAction("DROPDEFAULT");
            action.addElement(col_name);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case DROP:
      jj_consume_token(DROP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQLCOLUMN:
      case QUOTED_VARIABLE:
      case IDENTIFIER:
      case DOT_DELIMINATED_REF:
      case QUOTED_DELIMINATED_REF:
        if (jj_2_4(2)) {
          jj_consume_token(SQLCOLUMN);
        } else {
          ;
        }
        col_name = ColumnName();
            action.setAction("DROP");
            action.addElement(col_name);
        break;
      case CONSTRAINT:
        jj_consume_token(CONSTRAINT);
        con_name = ConstraintName();
            action.setAction("DROP_CONSTRAINT");
            action.addElement(con_name);
        break;
      case PRIMARY:
        jj_consume_token(PRIMARY);
        jj_consume_token(KEY);
            action.setAction("DROP_CONSTRAINT_PRIMARY_KEY");
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return action;}
    throw new Error("Missing return statement in function");
  }

// The list of columns to insert formatted as; eg.  (9, 4), (3, 2), (9, 9), ....
  final public void InsertDataList(ArrayList data_list) throws ParseException {
  Expression[] exps;
    jj_consume_token(154);
    exps = ExpressionList();
    jj_consume_token(155);
                                      data_list.add(exps);
    label_2:
    while (true) {
      if (jj_2_5(2)) {
        ;
      } else {
        break label_2;
      }
      jj_consume_token(156);
      jj_consume_token(154);
      exps = ExpressionList();
      jj_consume_token(155);
                                                       data_list.add(exps);
    }
  }

// Returning true means distinct, false means all.
  final public boolean SetQuantifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISTINCT:
      jj_consume_token(DISTINCT);
                  {if (true) return true;}
      break;
    case ALL:
      jj_consume_token(ALL);
                  {if (true) return false;}
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void SelectColumnList(ArrayList list) throws ParseException {
  SelectColumn col;
    col = SelectColumn();
                           list.add(col);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 156:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_3;
      }
      jj_consume_token(156);
      col = SelectColumn();
                               list.add(col);
    }
  }

  final public SelectColumn SelectColumn() throws ParseException {
  SelectColumn col = new SelectColumn();
  String aliased_name;
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IF:
    case NEW:
    case TRIM:
    case COUNT:
    case DATE:
    case TIME:
    case TIMESTAMP:
    case NOT:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case QUOTED_VARIABLE:
    case IDENTIFIER:
    case DOT_DELIMINATED_REF:
    case QUOTED_DELIMINATED_REF:
    case PARAMETER_REF:
    case 154:
      col.expression = DoExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTED_VARIABLE:
      case IDENTIFIER:
        col.alias = TableAliasName();
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      break;
    case STAR:
      jj_consume_token(STAR);
               col.glob_name = "*";
      break;
    case GLOBVARIABLE:
      t = jj_consume_token(GLOBVARIABLE);
                           col.glob_name = caseCheck(t.image);
      break;
    case QUOTEDGLOBVARIABLE:
      t = jj_consume_token(QUOTEDGLOBVARIABLE);
                                 col.glob_name = caseCheck(Util.asNonQuotedRef(t));
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return col;}
    throw new Error("Missing return statement in function");
  }

  final public void SelectGroupByList(ArrayList list) throws ParseException {
  ByColumn col;
  Expression exp;
    exp = DoExpression();
                           col = new ByColumn();
                           col.exp = exp;
                           list.add(col);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 156:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_4;
      }
      jj_consume_token(156);
      exp = DoExpression();
                               col = new ByColumn();
                               col.exp = exp;
                               list.add(col);
    }
  }

/**
 * NOTE: This is an extension, allows for us to specify a column to return the
 *  max value for each row representing a group.
 */
  final public Variable GroupMaxColumn() throws ParseException {
  Variable var;
    var = ColumnNameVariable();
    {if (true) return var;}
    throw new Error("Missing return statement in function");
  }

  final public void SelectOrderByList(ArrayList list) throws ParseException {
  ByColumn col;
  Expression exp;
  boolean ascending = true;
    exp = DoExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASC:
    case DESC:
      ascending = OrderingSpec();
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
                           col = new ByColumn();
                           col.exp = exp;
                           col.ascending = ascending;
                           list.add(col);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 156:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_5;
      }
      jj_consume_token(156);
      exp = DoExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
      case DESC:
        ascending = OrderingSpec();
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
                           col = new ByColumn();
                           col.exp = exp;
                           col.ascending = ascending;
                           list.add(col);
    }
  }

  final public boolean OrderingSpec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASC:
      jj_consume_token(ASC);
            {if (true) return true;}
      break;
    case DESC:
      jj_consume_token(DESC);
                                      {if (true) return false;}
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

  final public void TableDeclaration(FromClause from_clause) throws ParseException {
  String table=null, declare_as = null;
  TableSelectExpression select_stmt = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
    case IDENTIFIER:
    case DOT_DELIMINATED_REF:
    case QUOTED_DELIMINATED_REF:
      table = TableName();
      break;
    case 154:
      jj_consume_token(154);
      select_stmt = GetTableSelectExpression();
      jj_consume_token(155);
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case QUOTED_VARIABLE:
    case IDENTIFIER:
    case DOT_DELIMINATED_REF:
    case QUOTED_DELIMINATED_REF:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      declare_as = TableName();
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    from_clause.addTableDeclaration(table, select_stmt, declare_as);
  }

  final public void SelectTableList(FromClause from_clause) throws ParseException {
    TableDeclaration(from_clause);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT:
    case JOIN:
    case RIGHT:
    case INNER:
    case 156:
      FromClauseJoin(from_clause);
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
  }

  final public void FromClauseJoin(FromClause from_clause) throws ParseException {
  Expression on_expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 156:
      jj_consume_token(156);
          from_clause.addJoin(JoiningSet.INNER_JOIN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTED_VARIABLE:
      case IDENTIFIER:
      case DOT_DELIMINATED_REF:
      case QUOTED_DELIMINATED_REF:
      case 154:
        SelectTableList(from_clause);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      break;
    case JOIN:
    case INNER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INNER:
        jj_consume_token(INNER);
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
      jj_consume_token(JOIN);
      TableDeclaration(from_clause);
      jj_consume_token(ON);
      on_expression = DoExpression();
          from_clause.addPreviousJoin(JoiningSet.INNER_JOIN, on_expression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT:
      case JOIN:
      case RIGHT:
      case INNER:
      case 156:
        FromClauseJoin(from_clause);
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
      break;
    case LEFT:
      jj_consume_token(LEFT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OUTER:
        jj_consume_token(OUTER);
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jj_consume_token(JOIN);
      TableDeclaration(from_clause);
      jj_consume_token(ON);
      on_expression = DoExpression();
          from_clause.addPreviousJoin(JoiningSet.LEFT_OUTER_JOIN, on_expression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT:
      case JOIN:
      case RIGHT:
      case INNER:
      case 156:
        FromClauseJoin(from_clause);
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      break;
    case RIGHT:
      jj_consume_token(RIGHT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OUTER:
        jj_consume_token(OUTER);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      jj_consume_token(JOIN);
      TableDeclaration(from_clause);
      jj_consume_token(ON);
      on_expression = DoExpression();
          from_clause.addPreviousJoin(JoiningSet.RIGHT_OUTER_JOIN, on_expression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT:
      case JOIN:
      case RIGHT:
      case INNER:
      case 156:
        FromClauseJoin(from_clause);
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[60] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String TableName() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    case DOT_DELIMINATED_REF:
      name = jj_consume_token(DOT_DELIMINATED_REF);
      break;
    case QUOTED_DELIMINATED_REF:
      name = jj_consume_token(QUOTED_DELIMINATED_REF);
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCheck(Util.asNonQuotedRef(name));}
    throw new Error("Missing return statement in function");
  }

  final public String TriggerName() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCheck(Util.asNonQuotedRef(name));}
    throw new Error("Missing return statement in function");
  }

  final public String IndexName() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCheck(Util.asNonQuotedRef(name));}
    throw new Error("Missing return statement in function");
  }

// The ' set a = (a * 9), b = concat(b, "aa") ' part of the 'update', 'insert' statement
  final public void AssignmentList(ArrayList assignment_list) throws ParseException {
  String column;
  Expression exp;
    column = ColumnName();
    jj_consume_token(ASSIGNMENT);
    exp = DoExpression();
      assignment_list.add(new Assignment(Variable.resolve(column), exp));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 156:
      jj_consume_token(156);
      AssignmentList(assignment_list);
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
  }

// Parses a list of column declarations.  eg. ' id NUMERIC(5, 20), number VARCHAR(90), ... '
// and also any constraints.
  final public void ColumnDeclarationList(ArrayList column_list, ArrayList constraint_list) throws ParseException {
    jj_consume_token(154);
    ColumnOrConstraintDefinition(column_list, constraint_list);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 156:
        ;
        break;
      default:
        jj_la1[65] = jj_gen;
        break label_6;
      }
      jj_consume_token(156);
      ColumnOrConstraintDefinition(column_list, constraint_list);
    }
    jj_consume_token(155);
  }

  final public void ColumnOrConstraintDefinition(ArrayList column_list, ArrayList constraint_list) throws ParseException {
  ColumnDef coldef = null;
  ConstraintDef condef = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
    case IDENTIFIER:
    case DOT_DELIMINATED_REF:
    case QUOTED_DELIMINATED_REF:
      coldef = ColumnDefinition();
                                              column_list.add(coldef);
      break;
    case CHECK:
    case UNIQUE:
    case CONSTRAINT:
    case PRIMARY:
    case FOREIGN:
      condef = TableConstraintDefinition();
                                              constraint_list.add(condef);
      break;
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public ColumnDef ColumnDefinition() throws ParseException {
  ColumnDef column = new ColumnDef();
  Token t;
  Token col_constraint;
  Expression default_exp;
  String col_name;
    col_name = ColumnName();
                              column.setName(col_name);
    ColumnDataType(column);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQLDEFAULT:
      jj_consume_token(SQLDEFAULT);
      default_exp = DoExpression();
                                                  column.setDefaultExpression(default_exp);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULL_LITERAL:
      case UNIQUE:
      case PRIMARY:
      case NOT:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_7;
      }
      ColumnConstraint(column);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INDEX_NONE:
    case INDEX_BLIST:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEX_BLIST:
        t = jj_consume_token(INDEX_BLIST);
        break;
      case INDEX_NONE:
        t = jj_consume_token(INDEX_NONE);
        break;
      default:
        jj_la1[69] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                             column.setIndex(t);
      break;
    default:
      jj_la1[70] = jj_gen;
      ;
    }
    {if (true) return column;}
    throw new Error("Missing return statement in function");
  }

// Constraint on a column, eg. 'NOT NULL', 'NULL', 'PRIMARY KEY', 'UNIQUE', etc.
  final public void ColumnConstraint(ColumnDef column) throws ParseException {
  Token t;
  String table_name;
  ArrayList col_list = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(NULL_LITERAL);
                                column.addConstraint("NOT NULL");
      break;
    case NULL_LITERAL:
      jj_consume_token(NULL_LITERAL);
                         column.addConstraint("NULL");
      break;
    case PRIMARY:
      jj_consume_token(PRIMARY);
      jj_consume_token(KEY);
                          column.addConstraint("PRIMARY");
      break;
    case UNIQUE:
      jj_consume_token(UNIQUE);
                   column.addConstraint("UNIQUE");
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// Data type of a ColumnDef (eg. "varchar(50)", etc)
  final public void ColumnDataType(ColumnDef column) throws ParseException {
  String data_type;
  int size = -1;
  int scale = -1;
  Token class_tok = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JAVA_OBJECT:
      jj_consume_token(JAVA_OBJECT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 154:
        jj_consume_token(154);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT_DELIMINATED_REF:
          class_tok = jj_consume_token(DOT_DELIMINATED_REF);
          break;
        case JAVA_OBJECT_ARRAY_REF:
          class_tok = jj_consume_token(JAVA_OBJECT_ARRAY_REF);
          break;
        default:
          jj_la1[72] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(155);
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
        column.setDataType("JAVA_OBJECT", class_tok);
      break;
    case BIT:
    case INT:
    case REAL:
    case BLOB:
    case CHAR:
    case TEXT:
    case DATE:
    case TIME:
    case FLOAT:
    case BIGINT:
    case DOUBLE:
    case STRING:
    case BINARY:
    case NUMERIC:
    case DECIMAL:
    case BOOLEAN:
    case TINYINT:
    case INTEGER:
    case VARCHAR:
    case SMALLINT:
    case VARBINARY:
    case TIMESTAMP:
    case LONGVARCHAR:
    case LONGVARBINARY:
      data_type = GetDataType();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 154:
        jj_consume_token(154);
        size = PositiveIntegerConstant();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 156:
          jj_consume_token(156);
          scale = PositiveIntegerConstant();
          break;
        default:
          jj_la1[74] = jj_gen;
          ;
        }
        jj_consume_token(155);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
        column.setDataType(data_type, size, scale);
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String GetDataType() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BIT:
      t = jj_consume_token(BIT);
      break;
    case INT:
      t = jj_consume_token(INT);
      break;
    case REAL:
      t = jj_consume_token(REAL);
      break;
    case BLOB:
      t = jj_consume_token(BLOB);
      break;
    case CHAR:
      t = jj_consume_token(CHAR);
      break;
    case TEXT:
      t = jj_consume_token(TEXT);
      break;
    case DATE:
      t = jj_consume_token(DATE);
      break;
    case TIME:
      t = jj_consume_token(TIME);
      break;
    case FLOAT:
      t = jj_consume_token(FLOAT);
      break;
    case BIGINT:
      t = jj_consume_token(BIGINT);
      break;
    case DOUBLE:
      t = jj_consume_token(DOUBLE);
      break;
    case STRING:
      t = jj_consume_token(STRING);
      break;
    case BINARY:
      t = jj_consume_token(BINARY);
      break;
    case NUMERIC:
      t = jj_consume_token(NUMERIC);
      break;
    case DECIMAL:
      t = jj_consume_token(DECIMAL);
      break;
    case BOOLEAN:
      t = jj_consume_token(BOOLEAN);
      break;
    case TINYINT:
      t = jj_consume_token(TINYINT);
      break;
    case INTEGER:
      t = jj_consume_token(INTEGER);
      break;
    case VARCHAR:
      t = jj_consume_token(VARCHAR);
      break;
    case SMALLINT:
      t = jj_consume_token(SMALLINT);
      break;
    case VARBINARY:
      t = jj_consume_token(VARBINARY);
      break;
    case TIMESTAMP:
      t = jj_consume_token(TIMESTAMP);
      break;
    case LONGVARCHAR:
      t = jj_consume_token(LONGVARCHAR);
      break;
    case LONGVARBINARY:
      t = jj_consume_token(LONGVARBINARY);
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public ConstraintDef TableConstraintDefinition() throws ParseException {
  ConstraintDef constraint = new ConstraintDef();
  ArrayList column_list = new ArrayList();
  ArrayList column_list2 = new ArrayList();
  String constraint_name;
  String update_rule = "NO ACTION";
  String delete_rule = "NO ACTION";
  Expression expression;
  String name;
  String reference_table;
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTRAINT:
      jj_consume_token(CONSTRAINT);
      constraint_name = ConstraintName();
                                                        constraint.setName(constraint_name);
      break;
    default:
      jj_la1[78] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
      jj_consume_token(PRIMARY);
      jj_consume_token(KEY);
      jj_consume_token(154);
      BasicColumnList(column_list);
      jj_consume_token(155);
                                                               constraint.setPrimaryKey(column_list);
      break;
    case UNIQUE:
      jj_consume_token(UNIQUE);
      jj_consume_token(154);
      BasicColumnList(column_list);
      jj_consume_token(155);
                                                             constraint.setUnique(column_list);
      break;
    case CHECK:
      jj_consume_token(CHECK);
      jj_consume_token(154);
      expression = DoExpression();
      jj_consume_token(155);
                                                             constraint.setCheck(expression);
      break;
    case FOREIGN:
      jj_consume_token(FOREIGN);
      jj_consume_token(KEY);
      jj_consume_token(154);
      BasicColumnList(column_list);
      jj_consume_token(155);
      jj_consume_token(REFERENCES);
      reference_table = TableName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 154:
        jj_consume_token(154);
        BasicColumnList(column_list2);
        jj_consume_token(155);
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ON:
        if (jj_2_6(2)) {
          jj_consume_token(ON);
          jj_consume_token(DELETE);
          delete_rule = ReferentialTrigger();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ON:
            jj_consume_token(ON);
            jj_consume_token(UPDATE);
            update_rule = ReferentialTrigger();
            break;
          default:
            jj_la1[80] = jj_gen;
            ;
          }
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ON:
            jj_consume_token(ON);
            jj_consume_token(UPDATE);
            update_rule = ReferentialTrigger();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ON:
              jj_consume_token(ON);
              jj_consume_token(DELETE);
              delete_rule = ReferentialTrigger();
              break;
            default:
              jj_la1[81] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[82] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[83] = jj_gen;
        ;
      }
          constraint.setForeignKey(reference_table, column_list, column_list2, delete_rule, update_rule);
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INITIALLY:
    case DEFERRABLE:
    case NOT:
      ConstraintAttributes(constraint);
      break;
    default:
      jj_la1[85] = jj_gen;
      ;
    }
    {if (true) return constraint;}
    throw new Error("Missing return statement in function");
  }

  final public String ReferentialTrigger() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NO_ACTION:
      t = jj_consume_token(NO_ACTION);
      break;
    case CASCADE:
      t = jj_consume_token(CASCADE);
      break;
    case SET_NULL:
      t = jj_consume_token(SET_NULL);
      break;
    case SET_DEFAULT:
      t = jj_consume_token(SET_DEFAULT);
      break;
    default:
      jj_la1[86] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public void ConstraintAttributes(ConstraintDef constraint) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INITIALLY:
      jj_consume_token(INITIALLY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFERRED:
        jj_consume_token(DEFERRED);
                                      constraint.setInitiallyDeferred();
        break;
      case IMMEDIATE:
        jj_consume_token(IMMEDIATE);
        break;
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFERRABLE:
      case NOT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NOT:
          jj_consume_token(NOT);
          jj_consume_token(DEFERRABLE);
                                  constraint.setNotDeferrable();
          break;
        case DEFERRABLE:
          jj_consume_token(DEFERRABLE);
          break;
        default:
          jj_la1[88] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
      break;
    case DEFERRABLE:
    case NOT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
        jj_consume_token(DEFERRABLE);
                                constraint.setNotDeferrable();
        break;
      case DEFERRABLE:
        jj_consume_token(DEFERRABLE);
        break;
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INITIALLY:
        jj_consume_token(INITIALLY);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFERRED:
          jj_consume_token(DEFERRED);
                                        constraint.setInitiallyDeferred();
          break;
        case IMMEDIATE:
          jj_consume_token(IMMEDIATE);
          break;
        default:
          jj_la1[91] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[92] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// A list of column names
  final public void BasicColumnList(ArrayList list) throws ParseException {
  String col_name;
    col_name = ColumnName();
                                  list.add(col_name);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 156:
        ;
        break;
      default:
        jj_la1[94] = jj_gen;
        break label_8;
      }
      jj_consume_token(156);
      col_name = ColumnName();
                                  list.add(col_name);
    }
  }

  final public void ConditionsExpression(SearchExpression se) throws ParseException {
  Expression exp;
    exp = DoExpression();
    se.setFromExpression(exp);
  }

//
//void ConditionsExpression(ConditionTree cs) :
//{ Token logical; }
//{
//  
//  Conditional(cs) (
//    LOOKAHEAD(3) ( logical = <AND> | logical = <OR> )  { cs.addLogical(logical.image); }
//    Conditional(cs) )*
//
//}
//


//
//void Conditional(ConditionTree cs) :
//{ Expression exp; }
//{
////  (  c = Comparison()  { cs.addCondition(c); }
////    | "(" ConditionsExpression(cs.addConditionTree()) ")" )
//
//  (  LOOKAHEAD(5) exp = DoExpression()  { cs.addExpression(exp); }
//    | "(" ConditionsExpression(cs.addConditionTree()) ")" )
//    
//}
//
  final public Expression ExpressionTest() throws ParseException {
  Expression exp;
    exp = DoExpression();
    jj_consume_token(153);
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Expression DoExpression() throws ParseException {
  Stack stack = new Stack();
  Expression exp = new Expression();
    expression(exp, stack);
    expEnd(exp, stack);
    // Normalize the expression (remove any NOT operators)
    Expression normalized_exp = Util.normalize(exp);
    normalized_exp.copyTextFrom(exp);
    {if (true) return normalized_exp;}
    throw new Error("Missing return statement in function");
  }

  final public Expression DoNonBooleanExpression() throws ParseException {
  Stack stack = new Stack();
  Expression exp = new Expression();
    nonBooleanExpression(exp, stack);
    expEnd(exp, stack);
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parse an expression.
 */
  final public void expression(Expression exp, Stack stack) throws ParseException {
    Operand(exp, stack);
    label_9:
    while (true) {
      if (jj_2_7(2)) {
        ;
      } else {
        break label_9;
      }
      OpPart(exp, stack);
    }
  }

/**
 * Parses a non-boolean expression.
 */
  final public void nonBooleanExpression(Expression exp, Stack stack) throws ParseException {
    Operand(exp, stack);
    label_10:
    while (true) {
      if (jj_2_8(2)) {
        ;
      } else {
        break label_10;
      }
      NumericOperator(exp, stack);
      Operand(exp, stack);
    }
  }

  final public void OpPart(Expression exp, Stack stack) throws ParseException {
  Token t;
//  SelectStatement select;
//  Expression[] exp_arr;
  Expression regex_expression;
  Object regex_ob;
    if (jj_2_9(3)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGNMENT:
      case EQUALS:
      case GR:
      case LE:
      case GREQ:
      case LEEQ:
      case NOTEQ:
      case LIKE:
      case AND:
      case OR:
      case NOT:
        BooleanOperator(exp, stack);
        break;
      case STAR:
      case DIVIDE:
      case ADD:
      case SUBTRACT:
        NumericOperator(exp, stack);
        break;
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Operand(exp, stack);
    } else if (jj_2_10(2)) {
      jj_consume_token(IS);
      jj_consume_token(NULL_LITERAL);
        expOperator(exp, stack, Operator.get("=")); exp.addElement(null);
        exp.text().append(" is null");
    } else if (jj_2_11(3)) {
      jj_consume_token(IS);
      jj_consume_token(NOT);
      jj_consume_token(NULL_LITERAL);
        expOperator(exp, stack, Operator.get("<>")); exp.addElement(null);
        exp.text().append(" is not null");
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REGEX_LITERAL:
      case REGEX:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case REGEX:
          jj_consume_token(REGEX);
                    exp.text().append(" regex ");
                                 expOperator(exp, stack, Operator.get("regex"));
          expression(exp, stack);
          break;
        case REGEX_LITERAL:
          t = jj_consume_token(REGEX_LITERAL);
                          regex_ob = Util.toParamObject(t, case_insensitive_identifiers);
                          exp.text().append(" regex " + regex_ob);
                          expOperator(exp, stack, Operator.get("regex"));
                          exp.addElement(regex_ob);
          break;
        default:
          jj_la1[96] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[97] = jj_gen;
        if (jj_2_12(2)) {
          SubQueryOperator(exp, stack);
          SubQueryExpression(exp, stack);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BETWEEN:
          case NOT:
            BetweenPredicate(exp, stack);
            break;
          default:
            jj_la1[98] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }

  final public void Operand(Expression exp, Stack stack) throws ParseException {
  Token t, tt;
  FunctionDef f;
  String time_fname;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 154:
      jj_consume_token(154);
            stack.push(Operator.get("(")); exp.text().append("(");
      expression(exp, stack);
      jj_consume_token(155);
                                     expEndParen(exp, stack); exp.text().append(")");
      break;
    case PARAMETER_REF:
      t = jj_consume_token(PARAMETER_REF);
            Object param_resolve = createSubstitution(t.image);
            exp.addElement(param_resolve);
            exp.text().append('?');
      break;
    default:
      jj_la1[101] = jj_gen;
      if (jj_2_13(2)) {
        jj_consume_token(NOT);
        expOperator(exp, stack, Operator.get("not"));
        exp.text().append(" not ");
        Operand(exp, stack);
      } else if (jj_2_14(3)) {
        f = Function();
            exp.addElement(f); exp.text().append(f);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATE:
        case TIME:
        case TIMESTAMP:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DATE:
            tt = jj_consume_token(DATE);
                    time_fname="DATEOB";
            break;
          case TIME:
            tt = jj_consume_token(TIME);
                    time_fname="TIMEOB";
            break;
          case TIMESTAMP:
            tt = jj_consume_token(TIMESTAMP);
                         time_fname="TIMESTAMPOB";
            break;
          default:
            jj_la1[99] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          t = jj_consume_token(STRING_LITERAL);
      Object param_ob1 = Util.toParamObject(t, case_insensitive_identifiers);
      Expression[] exp_list = new Expression[] { new Expression(param_ob1) };
      f = Util.resolveFunctionName(time_fname, exp_list);
      exp.addElement(f);
      exp.text().append(tt.image).append(" ").append(t.image);
          break;
        case NEW:
          jj_consume_token(NEW);
          f = JavaInstantiation();
            exp.addElement(f); exp.text().append(f);
          break;
        case BOOLEAN_LITERAL:
        case NULL_LITERAL:
        case NUMBER_LITERAL:
        case STRING_LITERAL:
        case QUOTED_VARIABLE:
        case IDENTIFIER:
        case DOT_DELIMINATED_REF:
        case QUOTED_DELIMINATED_REF:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STRING_LITERAL:
            t = jj_consume_token(STRING_LITERAL);
            break;
          case NUMBER_LITERAL:
            t = jj_consume_token(NUMBER_LITERAL);
            break;
          case BOOLEAN_LITERAL:
            t = jj_consume_token(BOOLEAN_LITERAL);
            break;
          case NULL_LITERAL:
            t = jj_consume_token(NULL_LITERAL);
            break;
          case QUOTED_VARIABLE:
            t = jj_consume_token(QUOTED_VARIABLE);
            break;
          case DOT_DELIMINATED_REF:
            t = jj_consume_token(DOT_DELIMINATED_REF);
            break;
          case QUOTED_DELIMINATED_REF:
            t = jj_consume_token(QUOTED_DELIMINATED_REF);
            break;
          case IDENTIFIER:
            t = jj_consume_token(IDENTIFIER);
            break;
          default:
            jj_la1[100] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          Object param_ob = Util.toParamObject(t, case_insensitive_identifiers);
          exp.addElement(param_ob);
          exp.text().append(t.image);
//          if (t.kind == SQLConstants.STRING_LITERAL) exp.text().append("'" + param_ob + "'");
//          else exp.text().append(param_ob);

          break;
        default:
          jj_la1[102] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void SubQueryExpression(Expression exp, Stack stack) throws ParseException {
  TableSelectExpression select;
  Expression[] exp_arr;
    jj_consume_token(154);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      select = GetTableSelectExpression();
        exp.addElement(select);
        exp.text().append(" [SELECT]");
      break;
    default:
      jj_la1[103] = jj_gen;
      exp_arr = ExpressionList();
        exp.addElement(exp_arr);
        exp.text().append(" (" + Util.expressionListToString(exp_arr) + ")");
    }
    jj_consume_token(155);
  }

/*
// Parse a sub query expression.  For example,
// IN ( SELECT ... ), > ANY ( SELECT .... )
void SubQueryExpression(Expression exp, Stack stack) :
{ Token t = null, aat = null;
  String comparison_op = null;
  SelectStatement select;
  Expression[] exp_arr;
  Operator op;
}
{
  // Parse IN, NOT IN, (comparison) ANY, (comparison) ALL forms
  (   t=<IN> | t=<NOTIN>
    | comparison_op=GetComparisonOperator() ( aat=<ANY> | aat=<ALL> | aat=<SOME> )
  )
    { if (t != null) {
        op = Operator.get(t.image);
      }
      else {
        String sq_form = "SINGLE";
        if (aat != null) {
          sq_form = aat.image;
        }
        op = Operator.get(comparison_op).getSubQueryForm(sq_form);
      }
    }
  // Parse the subquery list (either a list or a select statement)
  "("
  (   select=Select()
      { expOperator(exp, stack, op); exp.addElement(select);
        exp.text().append(" " + op.toString() + " [SELECT]"); }
    | exp_arr=ExpressionList()
      { expOperator(exp, stack, op); exp.addElement(exp_arr);
        exp.text().append(" " + t.image + " ( " + Util.expressionListToString(exp_arr) + " )");
      }
  )
  ")"
}
*/

// Parses a simple positive integer constant.
  final public int PositiveIntegerConstant() throws ParseException {
  Token t;
    t = jj_consume_token(NUMBER_LITERAL);
    int val = Integer.parseInt(t.image);
    if (val < 0) generateParseException();
    {if (true) return val;}
    throw new Error("Missing return statement in function");
  }

  final public void SubQueryOperator(Expression exp, Stack stack) throws ParseException {
  Token t;
  String op_string;
  String query_type = "SINGLE";
  Operator op;
    if (jj_2_15(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        jj_consume_token(IN);
                              op = Operator.get("IN");
        break;
      case NOT:
        jj_consume_token(NOT);
        jj_consume_token(IN);
                                    op = Operator.get("NOT IN");
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGNMENT:
      case EQUALS:
      case GR:
      case LE:
      case GREQ:
      case LEEQ:
      case NOTEQ:
        op_string = GetSubQueryBooleanOperator();
                                                    op = Operator.get(op_string);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ALL:
        case ANY:
        case SOME:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ANY:
            t = jj_consume_token(ANY);
            break;
          case ALL:
            t = jj_consume_token(ALL);
            break;
          case SOME:
            t = jj_consume_token(SOME);
            break;
          default:
            jj_la1[105] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                         query_type=t.image;
          break;
        default:
          jj_la1[106] = jj_gen;
          ;
        }
      op = op.getSubQueryForm(query_type);
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    expOperator(exp, stack, op);
    exp.text().append(" " + op + " ");
  }

  final public void BetweenPredicate(Expression exp, Stack stack) throws ParseException {
  boolean not_s = false;
  Expression exp1, exp2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
              not_s = true;
      break;
    default:
      jj_la1[108] = jj_gen;
      ;
    }
    jj_consume_token(BETWEEN);
    exp1 = DoNonBooleanExpression();
    jj_consume_token(AND);
    exp2 = DoNonBooleanExpression();
    //Expression[] exp_list = new Expression[] { exp1, exp2 };
    //Operator op;
    //if (not_s) {
    //  op = Operator.get("not between");
    //  exp.text().append(" not between ");
    //}
    //else {
    //  op = Operator.get("between");
    //  exp.text().append(" between ");
    //}
    //expOperator(exp, stack, op);
    //exp.addElement(exp_list);
    //exp.text().append(exp1.text().toString());
    //exp.text().append(" and ");
    //exp.text().append(exp2.text().toString());

    // Flush the operator stack to precedence 8
    flushOperatorStack(exp, stack, 8);
    // Get the end expression
    Expression end_exp = exp.getEndExpression();
    if (not_s) {
      exp.concat(exp1);
      exp.addElement(Operator.get("<"));
      exp.concat(end_exp);
      exp.concat(exp2);
      exp.addElement(Operator.get(">"));
      exp.addElement(Operator.get("or"));
      exp.text().append(" not between ");
    }
    else {
      exp.concat(exp1);
      exp.addElement(Operator.get(">="));
      exp.concat(end_exp);
      exp.concat(exp2);
      exp.addElement(Operator.get("<="));
      exp.addElement(Operator.get("and"));
      exp.text().append(" between ");
    }
    exp.text().append(exp1.text().toString());
    exp.text().append(" and ");
    exp.text().append(exp2.text().toString());
  }

  final public void BooleanOperator(Expression exp, Stack stack) throws ParseException {
  Token t;
  String op_string;
  Operator op;
    op_string = GetBooleanOperator();
                                         op = Operator.get(op_string);
    expOperator(exp, stack, op);
    exp.text().append(" " + op + " ");
  }

  final public void NumericOperator(Expression exp, Stack stack) throws ParseException {
  Token t;
  String op_string;
  Operator op;
    op_string = GetNumericOperator();
                                         op = Operator.get(op_string);
    expOperator(exp, stack, op);
    exp.text().append(" " + op + " ");
  }

  final public String GetBooleanOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGNMENT:
      t = jj_consume_token(ASSIGNMENT);
      break;
    case EQUALS:
      t = jj_consume_token(EQUALS);
      break;
    case GR:
      t = jj_consume_token(GR);
      break;
    case LE:
      t = jj_consume_token(LE);
      break;
    case GREQ:
      t = jj_consume_token(GREQ);
      break;
    case LEEQ:
      t = jj_consume_token(LEEQ);
      break;
    case NOTEQ:
      t = jj_consume_token(NOTEQ);
      break;
    case LIKE:
      t = jj_consume_token(LIKE);
      break;
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(LIKE);
                                            {if (true) return "NOT LIKE";}
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    case OR:
      t = jj_consume_token(OR);
      break;
    default:
      jj_la1[109] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String GetSubQueryBooleanOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGNMENT:
      t = jj_consume_token(ASSIGNMENT);
      break;
    case EQUALS:
      t = jj_consume_token(EQUALS);
      break;
    case GR:
      t = jj_consume_token(GR);
      break;
    case LE:
      t = jj_consume_token(LE);
      break;
    case GREQ:
      t = jj_consume_token(GREQ);
      break;
    case LEEQ:
      t = jj_consume_token(LEEQ);
      break;
    case NOTEQ:
      t = jj_consume_token(NOTEQ);
      break;
    default:
      jj_la1[110] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String GetNumericOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIVIDE:
      t = jj_consume_token(DIVIDE);
      break;
    case ADD:
      t = jj_consume_token(ADD);
      break;
    case SUBTRACT:
      t = jj_consume_token(SUBTRACT);
      break;
    case STAR:
      t = jj_consume_token(STAR);
      break;
    default:
      jj_la1[111] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

/*
String GetOperator() :
{ Token t;
}
{
   (   t=<ASSIGNMENT> | t=<EQUALS> | t=<GR> | t=<LE> | t=<GREQ> | t=<LEEQ> | t=<NOTEQ>
     | t=<DIVIDE> | t=<ADD> | t=<SUBTRACT> | t=<LIKE> | t=<NOTLIKE> | t=<AND>
     | t=<OR>
     | t=<STAR>   // This is "*" (multiply) 
   )
   { return t.image; }
}
*/
  final public FunctionDef Function() throws ParseException {
  Token t, t2 = null, t3 = null;
  FunctionDef f;
  Expression exp1, exp2;
  Expression[] exp_list;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COUNT:
      t = jj_consume_token(COUNT);
      jj_consume_token(154);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        jj_consume_token(DISTINCT);
                                       t.image="distinct_count";
        break;
      default:
        jj_la1[112] = jj_gen;
        ;
      }
      exp_list = FunctionParams();
      jj_consume_token(155);
      break;
    case TRIM:
      t = jj_consume_token(TRIM);
      jj_consume_token(154);
      if (jj_2_16(3)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOTH:
        case LEADING:
        case TRAILING:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LEADING:
            t2 = jj_consume_token(LEADING);
            break;
          case BOTH:
            t2 = jj_consume_token(BOTH);
            break;
          case TRAILING:
            t2 = jj_consume_token(TRAILING);
            break;
          default:
            jj_la1[113] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[114] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          t3 = jj_consume_token(STRING_LITERAL);
          break;
        default:
          jj_la1[115] = jj_gen;
          ;
        }
        jj_consume_token(FROM);
      } else {
        ;
      }
      exp1 = DoExpression();
      jj_consume_token(155);
                          exp_list = new Expression[3];
                          String ttype = t2 == null ? "both" : t2.image.toLowerCase();
                          Object str_char = t3 == null ? " " : Util.toParamObject(t3, case_insensitive_identifiers);
                          exp_list[0] = new Expression(ttype);
                          exp_list[0].text().append("'" + ttype + "'");
                          exp_list[1] = new Expression(str_char);
                          exp_list[1].text().append("'" + str_char + "'");
                          exp_list[2] = exp1;
                          {if (true) return Util.resolveFunctionName("sql_trim", exp_list);}
      break;
    case IF:
      t = jj_consume_token(IF);
      jj_consume_token(154);
      exp_list = FunctionParams();
      jj_consume_token(155);
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(154);
      exp_list = FunctionParams();
      jj_consume_token(155);
      break;
    default:
      jj_la1[116] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return Util.resolveFunctionName(t.image, exp_list);}
    throw new Error("Missing return statement in function");
  }

// An instantiation of a java object.  For example, 'java.awt.Point(40, 30)'
  final public FunctionDef JavaInstantiation() throws ParseException {
  Token t;
  Expression[] args;
    // PENDING: Handling arrays (eg. 'java.lang.String[] { 'Tobias', 'Downer' }' or 'double[] { 25, 2, 75, 26 }' )
      t = jj_consume_token(DOT_DELIMINATED_REF);
    jj_consume_token(154);
    args = ExpressionList();
    jj_consume_token(155);
    Expression[] comp_args = new Expression[args.length + 1];
    System.arraycopy(args, 0, comp_args, 1, args.length);
    comp_args[0] = new Expression(t.image);
    comp_args[0].text().append("'" + t.image + "'");
    {if (true) return Util.resolveFunctionName("_new_JavaObject", comp_args);}
    throw new Error("Missing return statement in function");
  }

// Parameters for a function
  final public Expression[] FunctionParams() throws ParseException {
  Expression[] exp_list;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      jj_consume_token(STAR);
             exp_list = FunctionFactory.GLOB_LIST;
      break;
    default:
      jj_la1[117] = jj_gen;
      exp_list = ExpressionList();
    }
    {if (true) return exp_list;}
    throw new Error("Missing return statement in function");
  }

  final public Expression[] ExpressionList() throws ParseException {
  ArrayList list = new ArrayList();
  Expression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IF:
    case NEW:
    case TRIM:
    case COUNT:
    case DATE:
    case TIME:
    case TIMESTAMP:
    case NOT:
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case QUOTED_VARIABLE:
    case IDENTIFIER:
    case DOT_DELIMINATED_REF:
    case QUOTED_DELIMINATED_REF:
    case PARAMETER_REF:
    case 154:
      e = DoExpression();
                         list.add(e);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 156:
          ;
          break;
        default:
          jj_la1[118] = jj_gen;
          break label_11;
        }
        jj_consume_token(156);
        e = DoExpression();
                               list.add(e);
      }
      break;
    default:
      jj_la1[119] = jj_gen;
      ;
    }
    {if (true) return (Expression[]) list.toArray(new Expression[list.size()]);}
    throw new Error("Missing return statement in function");
  }

  final public String GetComposite() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNION:
      name = jj_consume_token(UNION);
      break;
    case INTERSECT:
      name = jj_consume_token(INTERSECT);
      break;
    case EXCEPT:
      name = jj_consume_token(EXCEPT);
      break;
    default:
      jj_la1[120] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return name.image;}
    throw new Error("Missing return statement in function");
  }

// Name of a schema
  final public String SchemaName() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[121] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCheck(Util.asNonQuotedRef(name));}
    throw new Error("Missing return statement in function");
  }

// Name of a constraint name
  final public String ConstraintName() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[122] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCheck(Util.asNonQuotedRef(name));}
    throw new Error("Missing return statement in function");
  }

// Parses a column name  
  final public String ColumnName() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    case DOT_DELIMINATED_REF:
      name = jj_consume_token(DOT_DELIMINATED_REF);
      break;
    case QUOTED_DELIMINATED_REF:
      name = jj_consume_token(QUOTED_DELIMINATED_REF);
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCheck(Util.asNonQuotedRef(name));}
    throw new Error("Missing return statement in function");
  }

// Parses a column name as a Variable object  
  final public Variable ColumnNameVariable() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    case DOT_DELIMINATED_REF:
      name = jj_consume_token(DOT_DELIMINATED_REF);
      break;
    case QUOTED_DELIMINATED_REF:
      name = jj_consume_token(QUOTED_DELIMINATED_REF);
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return (Variable) Util.toParamObject(name, case_insensitive_identifiers);}
    throw new Error("Missing return statement in function");
  }

// Parses an aliased table name  
  final public String TableAliasName() throws ParseException {
  Token name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUOTED_VARIABLE:
      name = jj_consume_token(QUOTED_VARIABLE);
      break;
    case IDENTIFIER:
      name = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[125] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCheck(Util.asNonQuotedRef(name));}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_8();
    jj_save(7, xla);
    return retval;
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_9();
    jj_save(8, xla);
    return retval;
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_10();
    jj_save(9, xla);
    return retval;
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_11();
    jj_save(10, xla);
    return retval;
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_12();
    jj_save(11, xla);
    return retval;
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_13();
    jj_save(12, xla);
    return retval;
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_14();
    jj_save(13, xla);
    return retval;
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_15();
    jj_save(14, xla);
    return retval;
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_16();
    jj_save(15, xla);
    return retval;
  }

  final private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_3R_13()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_18()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(REGEX_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(SOME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(ON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DELETE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(REGEX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(TRAILING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(BETWEEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_68()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(ALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_93() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_94()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_scan_token(IS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(NULL_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(BOTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_13()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(ANY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(IS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(NULL_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_63() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_62()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_93()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(STAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_12()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(LEADING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_scan_token(NOTEQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(DOT_DELIMINATED_REF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(LEEQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_23()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(FROM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(DISTINCT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(154)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(155)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(IF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(154)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(155)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(LEEQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(GREQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_scan_token(LE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(TRIM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(154)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(GREQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_3R_92()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(COUNT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(154)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(155)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(SUBTRACT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(GR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(LE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_scan_token(ADD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(GR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LIKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(STAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(DIVIDE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(LIKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_scan_token(154)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(NOTEQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(QUOTED_DELIMINATED_REF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(DOT_DELIMINATED_REF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(QUOTED_VARIABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(NULL_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(BOOLEAN_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(156)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(154)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(NEW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_61()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(SQLCOLUMN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(DATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(SQLCOLUMN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(ALTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(TABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(SQLCOLUMN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_scan_token(PARAMETER_REF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_scan_token(154)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public SQLTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[126];
  final private int[] jj_la1_0 = {0x7fe00000,0x1,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x1a000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0xa00000,0x0,0x0,0x0,0x0,0xc0080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ff80,0x100000,0x100000,0x0,0x0,0xc0000,0x0,0xc0000,0x1000000,0x0,0x0,0x0,0x7f00,0x0,0x7f00,0x7f00,0x38080,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0xc0000,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_1 = {0x40d,0x0,0x48000000,0x48000000,0x0,0x2000000,0x10000000,0x0,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x2000000,0x10000000,0x100000,0x0,0x0,0x400,0x0,0x0,0x2000000,0x1,0x40,0x0,0x100,0x20000,0x2000000,0x0,0x0,0x0,0x100,0x0,0x0,0x400,0x0,0x4000,0x100,0x0,0x20,0x0,0x1402080,0x0,0x81000,0x0,0x81000,0x81000,0x0,0x20,0x20,0x24240000,0x0,0x20000000,0x24240000,0x0,0x24240000,0x0,0x24240000,0x24240000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x40,0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x10300,0x10300,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x1400080,0x0,0x0,0x1402080,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_2 = {0x0,0x0,0x1008440,0x8040,0x80000,0x0,0x0,0x0,0x1000000,0x0,0x2,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x40,0x0,0x0,0x0,0x0,0x40,0x200000,0x0,0x0,0x0,0x200,0x40000,0x0,0x2000018,0x64000c02,0x0,0x24000800,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x64000402,0x10000,0x20000400,0x0,0x0,0x20000400,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x60000402,0x8800000,0x0,0x500000,0x8000000,0x8000000,0x8000000,0x500000,0x800000,0x8800000,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x21000,0x21000,0x0,0x0,0x0,0x0,0x0,0x2000018,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_3 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0xffffff8,0xdfffff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000600,0x0,0x0,0x1000600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000600,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_4 = {0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x4000000,0x0,0x4000000,0x8000,0x4000000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,0x0,0x3c000,0x0,0x0,0x10000000,0x0,0xc000,0x473f800,0x10000000,0x0,0x10000000,0x0,0x0,0x403c000,0x0,0x3c000,0x10000000,0x403c000,0x0,0x10000000,0x0,0x10000000,0x0,0x10000000,0x10000000,0x3c000,0xc000,0xc000,0x10000000,0x10000000,0x3c000,0x0,0x800,0x0,0x0,0x800,0x50000,0x4000000,0x10000000,0x4000000,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x800,0x3c,0x0,0x800,0x800,0x800,0x0,0x0,0x800,0x10000000,0xb40,0x80,0x80,0x800,0x0,0x3f000,0x4400000,0x3f000,0x0,0xc00,0x0,0x0,0x0,0x800,0xb40,0x0,0x0,0x0,0x0,0x0,0x2000,0x8000,0x0,0x10000000,0x443f800,0x0,0xc000,0xc000,0x3c000,0x3c000,0xc000,};
  final private JJCalls[] jj_2_rtns = new JJCalls[16];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public SQL(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new SQLTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 126; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 126; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public SQL(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new SQLTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 126; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 126; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public SQL(SQLTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 126; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(SQLTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 126; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[157];
    for (int i = 0; i < 157; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 126; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 157; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 16; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
